/**
* Copyright 2015 - 2022 Analog Devices Inc.
* Released under the ADRV904X API license, for more information
* see the "LICENSE.pdf" file in this zip file.
*/

/**
 * \file adrv904x_carrier_reconfigure.c
 * \brief Contains ADRV904X Rx related private function implementations
 *
 * ADRV904X API Version: 2.10.0.4
 */

#include "../../private/bf/adrv904x_bf_cddc_funcs.h"
#include "../../private/bf/adrv904x_bf_cddc_hb_dpath.h"
#include "../../private/bf/adrv904x_bf_cduc_funcs.h"
#include "../../private/bf/adrv904x_bf_cduc_hb_dpath.h"
#include "../../private/bf/adrv904x_bf_jesd_common.h"
#include "../../private/include/adrv904x_carrier_reconfigure.h"
#include "../../private/include/adrv904x_rx.h"
#include "../../private/include/adrv904x_tx.h"

#define ADRV904X_SLOTS_PER_REGISTER  (8U)
#define ADRV904X_LAST_VALID_SLOT_SELECT_IN_CARRIER_MODE (31U)
#define ADRV904X_JESD_INT_INTERLEAVING_RATIO (4U)
#define ADRV904X_JESD_INTERFACE_MAX_FREQ_KHZ (500000U)
#define ADRV904X_JESD_XBAR_NUM_COLUMNS (16U)
#define ADRV904X_RAND_TABLE_NUM_ARRAY_SIZES  (7)

#define ADI_FILE    ADI_ADRV904X_FILE_PRIVATE_CARRIER_RECONFIGURE

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_60000[] = {
       -30,     -6,     12,     14,      0,     -2,     11,     13,     -2,     -7,      9,     14,     -3,    -11,      6,     17,
        -2,    -15,      3,     19,      1,    -19,     -1,     22,      5,    -22,     -6,     24,     10,    -24,    -12,     26,
        16,    -25,    -20,     26,     24,    -25,    -28,     24,     33,    -22,    -37,     20,     42,    -17,    -46,     14,
        51,    -10,    -55,      5,     59,      0,    -63,     -6,     66,     13,    -69,    -21,     71,     29,    -73,    -38,
        74,     48,    -73,    -58,     72,     69,    -70,    -80,     66,     91,    -61,   -103,     55,    115,    -47,   -126,
        38,    138,    -26,   -149,     13,    159,      1,   -169,    -18,    178,     37,   -186,    -57,    193,     80,   -198,
      -105,    201,    132,   -203,   -161,    202,    193,   -198,   -228,    191,    265,   -181,   -305,    166,    349,   -147,
      -398,    122,    451,    -90,   -510,     50,    578,      2,   -656,    -69,    751,    157,   -869,   -279,   1028,    455,
     -1257,   -734,   1636,   1252,  -2423,  -2579,   5253,  14397
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_70000[] = {
        33,      1,    -18,     -7,      4,    -11,    -14,      6,      2,    -17,     -3,     12,     -9,    -16,     11,      8,
       -20,     -4,     20,     -7,    -22,     15,     16,    -24,     -9,     29,     -4,    -31,     16,     25,    -29,    -16,
        38,      1,    -42,     16,     38,    -34,    -27,     47,      9,    -55,     13,     53,    -37,    -42,     57,     21,
       -70,      7,     72,    -38,    -61,     66,     37,    -86,     -4,     94,    -35,    -85,     73,     60,   -103,    -21,
       119,    -27,   -116,     78,     91,   -121,    -46,    149,    -13,   -154,     78,    131,   -139,    -82,    183,     11,
      -201,     73,    185,   -156,   -133,    223,     49,   -261,     58,    257,   -171,   -206,    273,    108,   -343,     27,
       363,   -184,   -320,    340,    209,   -466,    -32,    535,   -195,   -521,    448,    402,   -694,   -164,    892,   -202,
      -995,    704,    941,  -1365,   -630,   2291,   -206,  -4014,   3201,  16180
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_80000[] = {
       -30,    -21,     16,     -7,     -3,      7,      0,    -11,     13,     -2,    -11,     11,      3,    -15,     12,      5,
       -18,     10,     10,    -21,      9,     15,    -23,      5,     20,    -24,      1,     26,    -24,     -5,     31,    -23,
       -12,     36,    -20,    -20,     41,    -16,    -30,     44,     -9,    -39,     45,      0,    -49,     45,     11,    -58,
        41,     24,    -66,     35,     39,    -73,     26,     54,    -78,     13,     70,    -79,     -3,     86,    -77,    -22,
       102,    -70,    -44,    115,    -59,    -69,    126,    -42,    -95,    132,    -20,   -122,    134,      7,   -150,    130,
        41,   -176,    118,     79,   -199,     99,    122,   -218,     70,    169,   -231,     31,    220,   -237,    -18,    272,
      -233,    -79,    326,   -216,   -154,    380,   -185,   -244,    432,   -134,   -352,    481,    -59,   -485,    526,     52,
      -652,    565,    216,   -877,    598,    476,  -1217,    624,    955,  -1859,    642,   2193,  -3891,    650,  17731
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_90000[] = {
       -24,     23,     24,      0,     14,      3,     -6,     13,     -7,     -2,     12,    -13,      6,      6,    -15,     14,
        -3,    -12,     19,    -14,     -2,     18,    -22,     11,      9,    -25,     24,     -5,    -18,     31,    -22,     -3,
        28,    -35,     18,     13,    -37,     36,    -10,    -26,     46,    -34,     -2,     40,    -52,     28,     18,    -54,
        54,    -16,    -36,     66,    -51,     -1,     56,    -75,     42,     22,    -75,     79,    -26,    -48,     93,    -75,
         3,     76,   -106,     63,     27,   -104,    112,    -42,    -63,    130,   -109,     10,    102,   -150,     95,     31,
      -143,    161,    -66,    -82,    182,   -160,     23,    139,   -215,    143,     35,   -201,    236,   -106,   -109,    263,
      -242,     47,    197,   -321,    226,     39,   -299,    369,   -181,   -155,    414,   -401,     98,    310,   -542,    408,
        41,   -521,    689,   -374,   -270,    830,   -875,    266,    693,  -1373,   1179,     42,  -1775,   2940,  -2219,  -1999,
     18993
};

static const int16_t adrv904x_cddc_coefs_5g_fs_122880_ibw_100000[] = {
       -39,     -8,     10,    -12,     12,    -10,      5,      1,     -7,     10,    -10,      5,      2,    -10,     16,    -16,
        11,     -2,     -8,     16,    -19,     15,     -5,     -8,     19,    -25,     21,    -10,     -5,     20,    -29,     28,
       -16,     -2,     21,    -34,     35,    -25,      4,     19,    -37,     43,    -34,     12,     16,    -40,     52,    -45,
        23,     10,    -41,     59,    -58,     35,      1,    -40,     66,    -71,     51,    -11,    -35,     72,    -85,     69,
       -27,    -27,     75,    -99,     89,    -47,    -15,     75,   -112,    111,    -71,      3,     70,   -123,    135,   -100,
        27,     61,   -132,    160,   -134,     58,     44,   -136,    186,   -173,     97,     19,   -136,    212,   -217,    146,
       -17,   -128,    237,   -269,    207,    -66,   -110,    260,   -330,    286,   -136,    -77,    282,   -404,    391,   -236,
       -22,    300,   -500,    541,   -388,     72,    315,   -643,    784,   -655,    254,    326,   -913,   1293,  -1272,    730,
       333,  -1788,   3392,  -4844,   5856,  26550
};

static const int16_t adrv904x_cddc_coefs_5g_fs_15360_ibw_5000[] = {
        15,    -21,    -24,    -20,     -6,     10,     16,      6,    -11,    -21,    -12,      8,     24,     20,     -4,    -27,
       -28,     -3,     28,     37,     13,    -26,    -45,    -25,     20,     52,     40,    -11,    -57,    -55,     -3,     57,
        71,     21,    -53,    -86,    -44,     43,     99,     70,    -26,   -107,    -98,      1,    109,    127,     31,   -102,
      -154,    -70,     85,    177,    116,    -57,   -193,   -166,     15,    200,    219,     40,   -193,   -272,   -109,    169,
       321,    194,   -124,   -362,   -292,     54,    391,    406,     47,   -402,   -536,   -189,    386,    686,    388,   -330,
      -867,   -680,    209,   1110,   1159,     51,  -1521,  -2175,   -761,   2724,   6906,   9739
};

static const int16_t adrv904x_cddc_coefs_5g_fs_15360_ibw_10000[] = {
        42,    -21,    -38,     35,    -15,    -58,     60,      0,    -92,     81,     29,   -140,     96,     78,   -201,     99,
       151,   -273,     79,    258,   -352,     26,    407,   -433,    -78,    614,   -511,   -264,    912,   -579,   -604,   1398,
      -633,  -1336,   2468,   -667,  -4119,   9341,  21166
};

static const int16_t adrv904x_cddc_coefs_5g_fs_245760_ibw_200000[] = {
       -73,    -20,     22,    -22,     19,     -9,     -4,     16,    -24,     22,    -11,     -6,     23,    -33,     30,    -15,
        -8,     29,    -41,     37,    -17,    -13,     40,    -54,     47,    -20,    -17,     51,    -67,     57,    -22,    -25,
        67,    -85,     70,    -26,    -33,     83,   -104,     84,    -28,    -45,    106,   -129,    102,    -32,    -58,    131,
      -157,    122,    -34,    -76,    164,   -193,    146,    -37,    -98,    204,   -237,    176,    -38,   -127,    257,   -294,
       215,    -41,   -167,    328,   -371,    267,    -42,   -225,    431,   -485,    345,    -44,   -316,    596,   -670,    474,
       -45,   -483,    910,  -1040,    748,    -46,   -898,   1778,  -2210,   1785,    -46,  -4048,  19824
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_25000[] = {
       -48,      5,      9,    -28,     44,    -48,     35,     -4,    -36,     72,    -87,     70,    -21,    -50,    117,   -153,
       137,    -64,    -49,    167,   -243,    241,   -145,    -26,    221,   -370,    406,   -293,     45,    273,   -552,    678,
      -570,    214,    316,   -863,   1227,  -1212,    693,    344,  -1777,   3370,  -4821,   5836,  26568
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_5000[] = {
        22,     -1,     -2,     -5,     -8,    -10,    -12,    -11,     -9,     -6,     -2,      2,      5,      7,      7,      4,
         0,     -4,     -8,    -11,    -11,     -8,     -4,      2,      7,     11,     13,     12,      7,      1,     -6,    -12,
       -15,    -16,    -12,     -5,      3,     11,     17,     19,     17,     11,      1,     -9,    -17,    -22,    -22,    -17,
        -7,      5,     16,     24,     27,     24,     14,      1,    -13,    -25,    -31,    -31,    -23,     -9,      7,     23,
        34,     37,     32,     19,      1,    -19,    -35,    -43,    -42,    -30,    -11,     11,     32,     47,     50,     43,
        24,     -1,    -26,    -47,    -58,    -55,    -39,    -13,     17,     44,     63,     67,     56,     31,     -3,    -37,
       -64,    -77,    -73,    -51,    -16,     24,     61,     84,     89,     72,     38,     -6,    -51,    -86,   -103,    -95,
       -65,    -18,     36,     83,    113,    117,     94,     48,    -12,    -72,   -118,   -138,   -126,    -84,    -20,     52,
       115,    154,    158,    125,     61,    -21,   -103,   -164,   -189,   -171,   -111,    -22,     78,    165,    217,    221,
       172,     79,    -38,   -153,   -240,   -274,   -245,   -156,    -23,    125,    254,    331,    335,    258,    113,    -72,
      -255,   -394,   -450,   -402,   -252,    -24,    236,    468,    615,    629,    489,    206,   -175,   -579,   -914,  -1087,
     -1019,   -666,    -24,    858,   1892,   2953,   3908,   4629,   5016
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_10000[] = {
       -25,      1,     10,     17,     16,      7,     -3,     -6,      1,     10,     13,      6,     -6,    -13,     -7,      7,
        16,     11,     -4,    -16,    -14,      2,     17,     18,      2,    -17,    -22,     -6,     17,     26,     11,    -14,
       -29,    -17,     11,     31,     24,     -6,    -33,    -30,      0,     33,     37,      7,    -32,    -44,    -16,     29,
        49,     25,    -24,    -54,    -36,     17,     57,     47,     -7,    -58,    -58,     -4,     57,     69,     18,    -53,
       -79,    -33,     46,     88,     50,    -36,    -94,    -68,     22,     98,     87,     -5,    -98,   -105,    -15,     94,
       123,     39,    -85,   -138,    -66,     72,    151,     95,    -53,   -161,   -127,     28,    166,    159,      4,   -165,
      -191,    -41,    157,    222,     85,   -141,   -251,   -135,    116,    277,    191,    -80,   -298,   -254,     32,    312,
       323,     31,   -317,   -399,   -112,    310,    483,    216,   -288,   -579,   -352,    245,    691,    535,   -168,   -833,
      -804,     34,   1038,   1253,    229,  -1414,  -2234,   -934,   2588,   6925,   9898
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_15000[] = {
        34,      2,    -26,    -20,     12,      9,    -26,    -24,     19,     23,    -27,    -36,     23,     41,    -25,    -54,
        20,     62,    -18,    -75,     11,     87,     -3,   -100,     -8,    112,     22,   -125,    -39,    137,     59,   -148,
       -83,    157,    111,   -164,   -143,    169,    180,   -170,   -222,    167,    268,   -158,   -321,    143,    380,   -120,
      -447,     88,    523,    -42,   -611,    -19,    716,    105,   -846,   -224,   1015,    400,  -1256,   -682,   1646,   1204,
     -2443,  -2536,   5281,  14360
};

static const int16_t adrv904x_cddc_coefs_5g_fs_30720_ibw_20000[] = {
       -34,     17,     32,    -11,      8,     32,    -21,     -4,     40,    -26,    -18,     52,    -25,    -36,     64,    -17,
       -58,     75,     -3,    -85,     82,     21,   -114,     83,     54,   -145,     73,     98,   -174,     50,    152,   -199,
        12,    215,   -213,    -47,    286,   -213,   -128,    362,   -191,   -236,    440,   -139,   -378,    517,    -47,   -562,
       588,    108,   -811,    651,    368,  -1181,    701,    856,  -1855,    736,   2112,  -3919,    754,  17674
};

static const int16_t adrv904x_cddc_coefs_5g_fs_491520_ibw_400000[] = {
       -73,    -20,     22,    -22,     19,     -9,     -4,     16,    -24,     22,    -11,     -6,     23,    -33,     30,    -15,
        -8,     29,    -41,     37,    -17,    -13,     40,    -54,     47,    -20,    -17,     51,    -67,     57,    -22,    -25,
        67,    -85,     70,    -26,    -33,     83,   -104,     84,    -28,    -45,    106,   -129,    102,    -32,    -58,    131,
      -157,    122,    -34,    -76,    164,   -193,    146,    -37,    -98,    204,   -237,    176,    -38,   -127,    257,   -294,
       215,    -41,   -167,    328,   -371,    267,    -42,   -225,    431,   -485,    345,    -44,   -316,    596,   -670,    474,
       -45,   -483,    910,  -1040,    748,    -46,   -898,   1778,  -2210,   1785,    -46,  -4048,  19824
};

static const int16_t adrv904x_cddc_coefs_5g_fs_61440_ibw_30000[] = {
       -30,      7,     28,     18,     -8,     -3,     23,     15,    -18,    -13,     23,     21,    -23,    -25,     25,     31,
       -24,    -37,     24,     45,    -22,    -53,     20,     61,    -17,    -70,     12,     79,     -5,    -89,     -3,     98,
        12,   -108,    -24,    117,     38,   -125,    -54,    133,     72,   -140,    -92,    145,    116,   -149,   -142,    151,
       171,   -150,   -203,    147,    238,   -140,   -277,    129,    320,   -113,   -368,     91,    421,    -62,   -480,     24,
       549,     25,   -628,    -90,    724,    177,   -844,   -297,   1004,    472,  -1235,   -751,   1615,   1269,  -2404,  -2596,
      5234,  14414
};

static const int16_t adrv904x_cddc_coefs_5g_fs_61440_ibw_40000[] = {
       -16,     34,     25,    -10,      7,     13,    -18,      4,     17,    -22,      1,     24,    -24,     -4,     31,    -25,
       -11,     40,    -25,    -21,     48,    -23,    -32,     56,    -17,    -46,     63,     -8,    -62,     68,      4,    -79,
        70,     21,    -97,     69,     42,   -116,     63,     67,   -133,     52,     97,   -149,     34,    131,   -161,      8,
       169,   -169,    -26,    210,   -170,    -70,    254,   -163,   -125,    298,   -145,   -193,    343,   -113,   -275,    388,
       -63,   -375,    430,     11,   -498,    468,    118,   -656,    503,    278,   -872,    532,    534,  -1204,    554,   1007,
     -1838,    570,   2238,  -3861,    578,  17769
};

static const int16_t adrv904x_cddc_coefs_5g_fs_61440_ibw_50000[] = {
        44,      3,     -9,     17,    -23,     22,    -14,      0,     15,    -27,     30,    -21,      1,     22,    -41,     47,
       -37,     12,     21,    -50,     64,    -56,     25,     20,    -63,     87,    -83,     47,     11,    -71,    112,   -116,
        77,     -4,    -78,    140,   -158,    119,    -32,    -77,    170,   -209,    176,    -74,    -67,    199,   -272,    253,
      -137,    -42,    228,   -350,    358,   -233,      6,    253,   -453,    511,   -385,     96,    275,   -603,    759,   -653,
       275,    292,   -879,   1274,  -1274,    751,    302,  -1760,   3379,  -4851,   5879,  26520
};

static const int16_t adrv904x_cddc_coefs_5g_fs_7680_ibw_5000[] = {
        55,      1,    -72,     94,      6,   -154,    158,     63,   -309,    247,    178,   -548,    337,    417,   -936,    424,
       901,  -1649,    490,   2177,  -3763,    527,  17778
};

static const int16_t adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_60000[] = {
       -41,    -51,     -8,     12,     13,    -17,     -6,     12,     11,    -16,    -10,     13,     14,    -15,    -15,     14,
        19,    -14,    -21,     12,     24,    -11,    -27,      9,     30,     -6,    -33,      3,     36,      0,    -39,     -5,
        41,      9,    -43,    -14,     45,     20,    -46,    -26,     46,     33,    -46,    -40,     45,     47,    -43,    -55,
        40,     63,    -37,    -71,     32,     78,    -26,    -86,     18,     93,    -10,   -100,      0,    107,     11,   -112,
       -23,    117,     36,   -121,    -51,    123,     66,   -124,    -83,    124,    101,   -121,   -120,    117,    140,   -110,
      -160,    102,    181,    -90,   -203,     76,    225,    -58,   -247,     37,    270,    -13,   -292,    -16,    314,     49,
      -336,    -88,    357,    133,   -377,   -185,    396,    245,   -415,   -316,    432,    401,   -447,   -504,    462,    634,
      -474,   -804,    485,   1039,   -494,  -1396,    501,   2019,   -506,  -3436,    509,  10417,  15874
};

static const int16_t adrv904x_cddc_coefs_lte_fs_15360_ibw_5000[] = {
         6,      1,     -5,    -13,    -18,    -15,     -5,      6,     10,      4,     -7,    -13,     -8,      5,     15,     13,
        -2,    -16,    -18,     -3,     16,     23,     10,    -14,    -28,    -18,      9,     31,     28,     -1,    -32,    -37,
        -9,     30,     46,     22,    -24,    -53,    -37,     14,     57,     53,      0,    -57,    -69,    -19,     52,     83,
        42,    -41,    -94,    -67,     23,    100,     93,      2,    -99,   -119,    -35,     89,    143,     72,    -69,   -160,
      -115,     38,    169,    159,      5,   -167,   -203,    -59,    151,    244,    124,   -119,   -276,   -198,     67,    297,
       280,      7,   -300,   -366,   -105,    281,    454,    231,   -231,   -540,   -391,    141,    620,    595,      8,   -691,
      -869,   -253,    750,   1280,    694,   -795,  -2060,  -1731,    822,   4869,   8587,  10091
};

static const int16_t adrv904x_cddc_coefs_lte_fs_15360_ibw_10000[] = {
       -26,    -24,     27,      8,    -39,     31,     36,    -70,     17,     88,    -95,    -29,    160,    -97,   -120,    238,
       -49,   -260,    298,     75,   -445,    302,    307,   -659,    196,    687,   -874,   -114,   1302,  -1060,   -877,   2531,
     -1186,  -3752,   9569,  20614
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_5000[] = {
         1,      1,      1,      1,      0,     -1,     -2,     -3,     -5,     -6,     -7,     -8,     -7,     -6,     -4,     -2,
         0,      2,      3,      4,      3,      2,      0,     -2,     -3,     -4,     -4,     -3,     -2,      1,      3,      4,
         5,      5,      3,      1,     -2,     -4,     -6,     -6,     -5,     -3,      0,      3,      6,      7,      7,      5,
         2,     -2,     -6,     -8,     -9,     -8,     -5,      0,      4,      8,     10,     10,      8,      4,     -2,     -7,
       -11,    -13,    -11,     -7,     -1,      5,     11,     14,     15,     12,      6,     -2,     -9,    -15,    -17,    -16,
       -11,     -3,      6,     14,     19,     20,     16,      9,     -1,    -11,    -19,    -23,    -22,    -15,     -5,      7,
        17,     25,     27,     22,     13,      0,    -14,    -24,    -30,    -29,    -21,     -8,      7,     22,     32,     35,
        30,     18,      1,    -16,    -31,    -39,    -38,    -29,    -12,      8,     27,     41,     45,     40,     25,      3,
       -20,    -39,    -50,    -50,    -38,    -17,      9,     34,     52,     58,     52,     33,      6,    -24,    -49,    -64,
       -65,    -50,    -24,      9,     42,     65,     75,     67,     44,      9,    -29,    -62,    -81,    -83,    -66,    -32,
        10,     52,     83,     96,     87,     58,     14,    -35,    -78,   -104,   -108,    -86,    -44,     11,     65,    106,
       124,    115,     78,     21,    -43,   -100,   -136,   -141,   -115,    -60,     11,     83,    139,    165,    153,    106,
        31,    -54,   -131,   -181,   -191,   -157,    -85,     11,    110,    188,    227,    214,    150,     48,    -72,   -182,
      -256,   -275,   -230,   -127,     12,    158,    277,    340,    326,    235,     80,   -107,   -284,   -409,   -449,   -385,
      -222,     12,    269,    491,    622,    619,    464,    172,   -210,   -607,   -929,  -1084,  -1000,   -634,     12,    891,
      1913,   2958,   3896,   4602,   4981
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_10000[] = {
        -9,    -10,     -7,      2,     13,     18,     14,      3,     -6,     -7,      3,     14,     16,      6,     -9,    -16,
        -9,      9,     22,     17,     -3,    -22,    -23,     -3,     23,     31,     12,    -20,    -37,    -23,     14,     42,
        35,     -4,    -43,    -48,     -9,     41,     60,     26,    -34,    -69,    -45,     22,     76,     66,     -4,    -77,
       -87,    -20,     71,    106,     49,    -57,   -121,    -82,     35,    130,    117,     -3,   -130,   -151,    -38,    119,
       183,     87,    -96,   -208,   -143,     57,    223,    203,     -2,   -224,   -265,    -69,    208,    323,    157,   -169,
      -375,   -262,    102,    414,    384,     -1,   -434,   -524,   -142,    426,    685,    345,   -377,   -877,   -644,    259,
      1131,   1131,     -1,  -1552,  -2158,   -710,   2764,   6900,   9693
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_15000[] = {
         7,      2,    -18,    -31,    -11,     18,     10,    -24,    -21,     25,     32,    -23,    -47,     17,     63,     -5,
       -79,    -13,     94,     38,   -104,    -71,    108,    110,   -104,   -155,     88,    205,    -57,   -255,     10,    304,
        56,   -346,   -144,    378,    255,   -392,   -392,    382,    557,   -339,   -758,    248,   1005,    -85,  -1329,   -200,
      1802,    741,  -2680,  -2110,   5592,  13985
};

static const int16_t adrv904x_cddc_coefs_lte_fs_30720_ibw_20000[] = {
       -24,    -29,     15,     13,    -31,      8,     36,    -41,    -15,     67,    -35,    -59,     94,     -1,   -119,     99,
        70,   -181,     61,    175,   -219,    -38,    302,   -200,   -207,    416,    -87,   -441,    471,    157,   -718,    402,
       574,  -1003,    107,   1250,  -1250,   -670,   2554,  -1419,  -3588,   9667,  20366
};

static const int16_t adrv904x_cddc_coefs_lte_fs_7680_ibw_5000[] = {
        14,    -25,    -55,     38,     20,    -94,     61,     83,   -178,     58,    202,   -290,      5,    405,   -418,   -141,
       729,   -549,   -464,   1268,   -661,  -1208,   2410,   -737,  -4034,   9360,  21081
};

static const int16_t adrv904x_cddc_coefs_lte_iot_fs_15360_ibw_10000[] = {
        10,      0,    -29,    -17,      9,    -10,    -10,     17,     -8,    -14,     23,     -7,    -22,     30,     -4,    -32,
        36,      2,    -45,     42,     11,    -60,     48,     23,    -78,     51,     40,    -99,     52,     62,   -121,     50,
        89,   -146,     43,    124,   -172,     30,    167,   -199,      8,    218,   -227,    -23,    281,   -254,    -67,    358,
      -280,   -130,    452,   -305,   -217,    574,   -327,   -343,    738,   -346,   -536,    981,   -362,   -865,   1404,   -373,
     -1567,   2406,   -380,  -4305,   9214,  21463
};

static const int16_t adrv904x_cddc_coefs_lte_iot_fs_30720_ibw_20000[] = {
        19,     30,     -1,    -15,     13,      5,    -20,     12,     14,    -27,      6,     28,    -32,     -6,     44,    -32,
       -26,     61,    -23,    -52,     73,     -2,    -84,     76,     32,   -117,     65,     80,   -146,     34,    139,   -161,
       -19,    203,   -156,    -98,    265,   -120,   -201,    315,    -45,   -324,    338,     78,   -463,    319,    259,   -607,
       235,    513,   -746,     53,    871,   -869,   -302,   1424,   -965,  -1065,   2564,  -1027,  -3896,   9505,  20797
};

static const int16_t adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_100000[] = {
        52,     17,    -16,     16,    -13,      8,     -1,     -6,     11,    -13,      9,     -1,     -8,     16,    -19,     16,
        -7,     -5,     16,    -21,     20,    -10,     -4,     18,    -27,     27,    -17,      1,     17,    -30,     33,    -24,
         6,     16,    -34,     41,    -34,     14,     12,    -36,     49,    -44,     24,      7,    -37,     56,    -57,     36,
        -2,    -36,     63,    -69,     51,    -14,    -31,     68,    -83,     69,    -29,    -23,     71,    -96,     88,    -49,
       -11,     70,   -109,    110,    -72,      6,     66,   -119,    134,   -101,     30,     56,   -128,    158,   -134,     60,
        40,   -132,    184,   -173,     99,     15,   -131,    209,   -217,    148,    -20,   -123,    233,   -268,    209,    -70,
      -105,    257,   -328,    287,   -139,    -73,    278,   -402,    392,   -239,    -18,    296,   -498,    541,   -391,     76,
       311,   -641,    784,   -657,    258,    322,   -910,   1292,  -1274,    734,    329,  -1784,   3390,  -4846,   5859,  26545
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_60000[] = {
        -4,   -113,    139,    -62,    -37,     33,     27,    -22,    -25,     16,     26,    -12,    -27,      8,     28,     -5,
       -29,      1,     31,      2,    -32,     -6,     33,     10,    -33,    -14,     33,     19,    -33,    -23,     32,     28,
       -31,    -32,     30,     37,    -27,    -42,     24,     47,    -21,    -51,     16,     55,    -11,    -59,      6,     63,
         1,    -66,     -7,     69,     15,    -71,    -23,     72,     32,    -72,    -41,     71,     50,    -69,    -60,     66,
        70,    -62,    -80,     57,     90,    -50,   -100,     42,    109,    -33,   -118,     22,    126,    -10,   -133,     -4,
       140,     19,   -145,    -35,    149,     53,   -152,    -71,    152,     91,   -150,   -113,    147,    135,   -141,   -157,
       133,    181,   -121,   -205,    107,    229,    -89,   -254,     68,    279,    -43,   -304,     13,    328,     21,   -352,
       -61,    375,    107,   -397,   -160,    419,    222,   -439,   -295,    457,    381,   -474,   -487,    490,    619,   -504,
      -791,    516,   1029,   -525,  -1388,    533,   2012,   -539,  -3432,    542,  10416,  15841
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_70000[] = {
        13,   -116,    118,    -64,    -20,     46,     -3,    -36,     14,     28,    -24,    -19,     31,      8,    -35,      6,
        34,    -19,    -28,     32,     17,    -40,     -1,     43,    -17,    -39,     34,     28,    -47,    -10,     54,    -12,
       -52,     35,     41,    -54,    -22,     66,     -4,    -68,     33,     58,    -59,    -37,     78,      7,    -85,     27,
        79,    -62,    -58,     89,     24,   -104,     17,    103,    -61,    -84,     99,     48,   -124,      0,    131,    -55,
      -117,    106,     80,   -145,    -25,    164,    -41,   -157,    109,    122,   -166,    -61,    201,    -18,   -206,    105,
       177,   -185,   -112,    244,     19,   -270,     91,    252,   -203,   -187,    297,     79,   -355,     62,    360,   -218,
      -303,    366,    180,   -481,      3,    535,   -230,   -506,    477,    375,   -712,   -129,    896,   -238,   -983,    735,
       915,  -1386,   -596,   2297,   -243,  -4004,   3234,  16156
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_80000[] = {
       -52,      1,     47,    -94,    104,    -65,      8,     24,    -11,    -21,     34,    -10,    -23,     29,     -1,    -29,
        28,      6,    -34,     24,     14,    -38,     20,     22,    -41,     14,     31,    -43,      6,     40,    -43,     -3,
        48,    -41,    -14,     56,    -36,    -26,     62,    -29,    -39,     66,    -19,    -53,     68,     -6,    -66,     66,
        10,    -79,     61,     27,    -89,     53,     47,    -98,     40,     67,   -103,     23,     88,   -103,      1,    108,
       -99,    -23,    126,    -90,    -52,    142,    -74,    -82,    153,    -52,   -114,    159,    -24,   -147,    159,     11,
      -179,    151,     52,   -208,    134,     99,   -233,    107,    151,   -252,     68,    207,   -263,     18,    265,   -263,
       -45,    325,   -251,   -123,    386,   -222,   -216,    444,   -174,   -329,    499,    -99,   -467,    550,     12,   -640,
       595,    178,   -872,    632,    441,  -1219,    661,    923,  -1868,    681,   2166,  -3906,    691,  17709
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_90000[] = {
       -60,     38,    -22,    -11,     49,    -75,     77,    -55,     21,      5,    -10,     -6,     28,    -40,     32,     -7,
       -19,     27,    -13,    -14,     35,    -34,     11,     20,    -38,     28,      3,    -34,     43,    -23,    -14,     43,
       -43,     12,     30,    -52,     40,      2,    -44,     58,    -31,    -19,     58,    -58,     17,     39,    -70,     53,
         2,    -59,     77,    -42,    -25,     77,    -78,     24,     50,    -93,     72,      1,    -77,    102,    -56,    -32,
       102,   -104,     32,     66,   -123,     96,      1,   -102,    136,    -76,    -41,    136,   -139,     44,     87,   -164,
       129,      0,   -136,    183,   -103,    -55,    184,   -189,     61,    119,   -225,    178,      0,   -189,    256,   -145,
       -78,    260,   -270,     87,    172,   -328,    261,     -1,   -282,    386,   -221,   -119,    406,   -427,    140,    280,
      -544,    441,     -1,   -499,    701,   -413,   -231,    817,   -897,    308,    659,  -1371,   1210,     -1,  -1748,   2947,
     -2256,  -1958,  18975
};

static const int16_t adrv904x_cduc_coefs_5g_fs_122880_ibw_100000[] = {
         0,    -63,     51,    -59,     59,    -50,     32,    -10,    -11,     26,    -30,     24,     -9,     -9,     23,    -29,
        25,    -12,     -6,     23,    -32,     30,    -17,     -3,     23,    -35,     35,    -23,      2,     21,    -38,     42,
       -31,      8,     18,    -40,     48,    -40,     17,     14,    -41,     55,    -50,     26,      7,    -40,     60,    -60,
        38,     -1,    -37,     65,    -71,     51,    -12,    -33,     68,    -81,     66,    -26,    -25,     70,    -92,     82,
       -42,    -15,     69,   -101,     99,    -61,     -1,     65,   -110,    117,    -83,     17,     58,   -116,    135,   -107,
        39,     47,   -120,    154,   -135,     66,     31,   -121,    173,   -166,     98,      9,   -118,    192,   -200,    137,
       -21,   -110,    209,   -239,    185,    -59,    -95,    226,   -284,    243,   -111,    -71,    241,   -337,    317,   -180,
       -34,    255,   -402,    416,   -278,     23,    266,   -490,    558,   -426,    119,    276,   -625,    793,   -688,    300,
       282,   -886,   1293,  -1298,    774,    286,  -1754,   3382,  -4862,   5895,  26502
};

static const int16_t adrv904x_cduc_coefs_5g_fs_15360_ibw_5000[] = {
        40,   -205,     88,     82,     18,    -39,    -60,    -32,     24,     62,     48,    -12,    -66,    -65,     -3,     68,
        84,     22,    -67,   -103,    -46,     60,    121,     75,    -46,   -136,   -108,     24,    148,    146,      7,   -152,
      -185,    -49,    147,    226,    101,   -131,   -265,   -165,     99,    299,    241,    -50,   -326,   -329,    -22,    342,
       429,    123,   -340,   -544,   -260,    314,    678,    451,   -252,   -844,   -732,    126,   1071,   1198,    134,  -1468,
     -2200,   -842,   2659,   6914,   9814
};

static const int16_t adrv904x_cduc_coefs_5g_fs_15360_ibw_10000[] = {
      -102,    129,    -92,     -4,     83,    -57,    -40,    103,    -41,    -80,    123,    -14,   -128,    135,     30,   -181,
       131,     95,   -234,    103,    181,   -279,     44,    286,   -305,    -55,    407,   -299,   -203,    536,   -243,   -412,
       665,   -110,   -702,    785,    145,  -1125,    885,    646,  -1861,    957,   1934,  -3989,    994,  17544
};

static const int16_t adrv904x_cduc_coefs_5g_fs_245760_ibw_200000[] = {
       -63,     45,    -46,     36,    -15,    -13,     41,    -61,     67,    -57,     33,     -4,    -21,     33,    -26,      4,
        27,    -56,     71,    -64,     38,      1,    -39,     63,    -62,     34,     10,    -57,     89,    -92,     63,    -10,
       -49,     93,   -104,     76,    -16,    -56,    113,   -134,    108,    -40,    -47,    122,   -157,    135,    -61,    -43,
       139,   -191,    177,    -95,    -28,    150,   -225,    223,   -136,     -9,    163,   -270,    284,   -194,     22,    173,
      -322,    363,   -271,     67,    184,   -392,    475,   -387,    141,    191,   -494,    648,   -575,    267,    197,   -670,
       971,   -950,    541,    201,  -1093,   1847,  -2126,   1580,    204,  -4249,  19901
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_25000[] = {
       -27,     90,    -70,     87,    -65,     31,     16,    -57,     78,    -70,     33,     23,    -76,    107,    -98,     48,
        27,   -102,    146,   -136,     71,     31,   -134,    196,   -188,    103,     34,   -175,    264,   -258,    147,     37,
      -230,    356,   -355,    211,     39,   -309,    493,   -505,    311,     41,   -437,    724,   -766,    496,     42,   -693,
      1221,  -1375,    972,     43,  -1558,   3308,  -4938,   6093,  26258
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_5000[] = {
       140,   -189,    -73,     -8,     25,     38,     38,     29,     16,      2,    -12,    -23,    -29,    -28,    -21,    -10,
         4,     18,     28,     32,     28,     18,      3,    -14,    -28,    -36,    -36,    -27,    -11,      8,     27,     40,
        44,     37,     22,      0,    -23,    -42,    -51,    -49,    -34,    -11,     17,     42,     57,     60,     48,     24,
        -7,    -38,    -62,    -71,    -64,    -41,     -7,     31,     63,     81,     81,     61,     25,    -18,    -60,    -88,
       -97,    -83,    -48,      1,     51,     92,    113,    107,     75,     23,    -37,    -91,   -126,   -132,   -106,    -54,
        14,     83,    135,    157,    142,     92,     17,    -66,   -138,   -180,   -181,   -138,    -59,     39,    133,    200,
       223,    193,    114,      3,   -116,   -215,   -268,   -260,   -187,    -63,     85,    223,    317,    341,    284,    152,
       -29,   -219,   -372,   -448,   -421,   -286,    -66,    195,    440,    605,    640,    518,    247,   -132,   -544,   -896,
     -1090,  -1042,   -703,    -68,    819,   1866,   2947,   3923,   4661,   5058
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_10000[] = {
      -141,    164,     33,    -33,    -42,    -13,     25,     42,     27,     -9,    -34,    -28,      6,     38,     38,      4,
       -35,    -43,    -10,     35,     51,     21,    -31,    -57,    -31,     27,     63,     43,    -19,    -67,    -55,     10,
        70,     68,      1,    -71,    -81,    -16,     69,     94,     32,    -64,   -107,    -51,     56,    118,     72,    -44,
      -127,    -95,     28,    133,    120,     -7,   -136,   -145,    -19,    134,    171,     49,   -127,   -196,    -85,    114,
       220,    125,    -94,   -241,   -171,     66,    259,    222,    -28,   -272,   -278,    -21,    279,    340,     83,   -278,
      -408,   -162,    265,    484,    262,   -239,   -571,   -393,    192,    675,    571,   -114,   -809,   -833,    -22,   1007,
      1274,    284,  -1376,  -2247,   -987,   2544,   6930,   9948
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_15000[] = {
        80,   -170,     65,     39,    -46,    -46,     27,     47,    -21,    -54,     13,     60,     -6,    -67,     -3,     73,
        13,    -79,    -25,     83,     38,    -86,    -53,     88,     70,    -87,    -88,     84,    107,    -77,   -128,     68,
       148,    -54,   -169,     37,    190,    -15,   -210,    -12,    228,     44,   -244,    -81,    257,    123,   -266,   -172,
       270,    227,   -269,   -288,    259,    357,   -241,   -435,    212,    522,   -170,   -622,    109,    738,    -23,   -880,
       -98,   1061,    277,  -1313,   -563,   1715,   1090,  -2522,  -2429,   5371,  14261
};

static const int16_t adrv904x_cduc_coefs_5g_fs_30720_ibw_20000[] = {
       -82,     71,    -23,    -59,    109,    -84,     12,     33,     -1,    -67,     89,    -28,    -53,     62,     18,    -98,
        79,     29,   -107,     59,     72,   -135,     46,    105,   -143,     10,    152,   -150,    -32,    193,   -138,    -91,
       236,   -113,   -160,    269,    -64,   -242,    291,      8,   -332,    291,    109,   -427,    265,    243,   -523,    200,
       418,   -615,     81,    647,   -698,   -122,    964,   -769,   -477,   1465,   -822,  -1222,   2548,   -856,  -4018,   9432,
     20978
};

static const int16_t adrv904x_cduc_coefs_5g_fs_491520_ibw_400000[] = {
       -60,     42,    -43,     32,    -10,    -18,     45,    -65,     70,    -58,     34,     -5,    -20,     32,    -26,      3,
        28,    -56,     70,    -63,     36,      3,    -41,     64,    -62,     34,     11,    -57,     88,    -90,     61,     -8,
       -51,     94,   -105,     76,    -16,    -56,    113,   -133,    106,    -38,    -49,    124,   -158,    135,    -60,    -44,
       139,   -191,    175,    -93,    -30,    151,   -226,    222,   -135,    -11,    164,   -270,    283,   -192,     20,    175,
      -323,    363,   -270,     65,    185,   -393,    475,   -386,    138,    193,   -495,    648,   -574,    265,    199,   -671,
       971,   -949,    539,    204,  -1095,   1848,  -2125,   1578,    206,  -4251,  19902
};

static const int16_t adrv904x_cduc_coefs_5g_fs_61440_ibw_30000[] = {
       -85,    161,    -61,    -31,     45,     36,    -24,    -32,     22,     38,    -14,    -40,     10,     44,     -5,    -48,
        -1,     51,      7,    -54,    -14,     57,     22,    -58,    -31,     59,     40,    -59,    -50,     57,     60,    -54,
       -71,     50,     82,    -44,    -93,     36,    104,    -26,   -115,     14,    125,     -1,   -133,    -15,    141,     33,
      -147,    -53,    151,     75,   -153,    -99,    153,    124,   -149,   -151,    142,    180,   -131,   -209,    116,    240,
       -96,   -271,     71,    303,    -41,   -335,      4,    366,     41,   -397,    -94,    427,    156,   -456,   -231,    483,
       321,   -508,   -430,    531,    567,   -552,   -746,    570,    991,   -585,  -1357,    596,   1990,   -605,  -3419,    610,
     10411,  15772
};

static const int16_t adrv904x_cduc_coefs_5g_fs_61440_ibw_40000[] = {
        46,   -119,     88,    -61,    -12,     42,    -28,    -17,     38,    -16,    -25,     37,     -7,    -33,     36,      2,
       -40,     34,     13,    -48,     30,     24,    -53,     23,     36,    -58,     13,     49,    -59,      1,     62,    -58,
       -14,     74,    -53,    -31,     85,    -44,    -51,     93,    -30,    -72,     97,    -12,    -93,     97,     11,   -113,
        91,     38,   -131,     78,     69,   -146,     59,    102,   -155,     32,    137,   -158,     -2,    171,   -153,    -44,
       204,   -138,    -93,    232,   -111,   -148,    255,    -72,   -209,    268,    -20,   -272,    270,     49,   -339,    257,
       134,   -405,    225,    239,   -470,    169,    367,   -531,     82,    526,   -587,    -52,    730,   -635,   -259,   1016,
      -674,   -608,   1481,   -703,  -1338,   2525,   -721,  -4108,   9373,  21118
};

static const int16_t adrv904x_cduc_coefs_5g_fs_61440_ibw_50000[] = {
        58,    -30,     24,     -6,    -20,     48,    -71,     80,    -73,     50,    -17,    -15,     36,    -39,     22,      9,
       -43,     66,    -69,     48,     -8,    -36,     69,    -79,     58,    -13,    -41,     85,   -101,     81,    -29,    -38,
        96,   -123,    106,    -47,    -34,    109,   -150,    137,    -72,    -26,    122,   -180,    175,   -104,    -12,    134,
      -215,    222,   -146,      8,    145,   -257,    282,   -202,     39,    155,   -309,    361,   -280,     85,    164,   -378,
       472,   -395,    158,    171,   -479,    644,   -584,    285,    177,   -654,    966,   -958,    558,    181,  -1077,   1842,
     -2133,   1597,    183,  -4232,  19895
};

static const int16_t adrv904x_cduc_coefs_5g_fs_7680_ibw_5000[] = {
       -89,     61,     43,   -171,    177,    -23,   -137,    103,    116,   -258,    101,    219,   -312,     -5,    398,   -349,
      -186,    597,   -294,   -494,    813,    -94,   -975,   1012,    395,  -1802,   1165,   1714,  -4036,   1249,  17398
};

static const int16_t adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_60000[] = {
      -103,    179,    -19,    -27,     30,     41,     -6,    -31,      5,     34,      2,    -33,     -7,     34,     11,    -34,
       -16,     33,     21,    -33,    -26,     32,     31,    -30,    -36,     28,     41,    -25,    -46,     21,     50,    -17,
       -55,     12,     59,     -6,    -63,      0,     66,      8,    -69,    -15,     71,     24,    -72,    -33,     72,     42,
       -71,    -52,     69,     62,    -66,    -73,     62,     83,    -56,    -93,     49,    103,    -40,   -113,     30,    122,
       -18,   -130,      5,    138,      9,   -144,    -25,    149,     43,   -152,    -62,    154,     82,   -154,   -103,    151,
       126,   -147,   -149,    139,    173,   -129,   -198,    115,    224,    -98,   -249,     78,    275,    -53,   -301,     24,
       326,     10,   -351,    -50,    376,     96,   -399,   -149,    422,    212,   -443,   -285,    463,    372,   -481,   -478,
       498,    611,   -512,   -784,    525,   1023,   -535,  -1383,    544,   2009,   -550,  -3431,    553,  10415,  15830
};

static const int16_t adrv904x_cduc_coefs_lte_fs_15360_ibw_5000[] = {
        40,    -17,    -26,    -27,    -13,      8,     18,      9,    -14,    -29,    -21,      6,     31,     29,     -1,    -34,
       -40,    -10,     33,     50,     22,    -29,    -59,    -38,     21,     67,     56,     -7,    -71,    -75,    -11,     70,
        95,     35,    -63,   -113,    -64,     49,    127,     96,    -26,   -136,   -132,     -6,    137,    168,     48,   -127,
      -202,    -99,    105,    232,    158,    -68,   -254,   -225,     14,    264,    297,     59,   -259,   -372,   -154,    232,
       448,    275,   -176,   -522,   -427,     83,    591,    621,     67,   -652,   -884,   -309,    702,   1282,    745,   -740,
     -2050,  -1774,    763,   4847,   8621,  10152
};

static const int16_t adrv904x_cduc_coefs_lte_fs_15360_ibw_10000[] = {
        50,    -52,    -36,     59,    -38,    -72,     99,     -5,   -138,    123,     66,   -221,    108,    187,   -303,     27,
       360,   -349,   -150,    573,   -313,   -455,    804,   -124,   -944,   1020,    358,  -1786,   1189,   1682,  -4038,   1282,
     17378
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_5000[] = {
        26,     35,    -11,     11,     -7,     -2,    -10,     -8,     -9,     -5,     -1,      5,      9,     11,     11,      8,
         3,     -3,     -9,    -13,    -14,    -12,     -7,      0,      8,     14,     17,     17,     12,      4,     -5,    -14,
       -20,    -21,    -18,    -10,      1,     12,     21,     25,     24,     17,      5,     -8,    -21,    -28,    -30,    -24,
       -13,      3,     18,     30,     36,     33,     22,      5,    -13,    -30,    -40,    -41,    -33,    -16,      6,     27,
        42,     49,     44,     28,      5,    -20,    -42,    -55,    -55,    -42,    -19,     10,     38,     59,     66,     58,
        36,      4,    -30,    -59,    -74,    -73,    -55,    -22,     17,     54,     80,     88,     75,     44,      1,    -44,
       -81,   -100,    -96,    -70,    -25,     28,     76,    109,    117,     98,     55,     -4,    -64,   -112,   -136,   -128,
       -90,    -28,     44,    108,    150,    158,    129,     68,    -13,    -95,   -158,   -188,   -174,   -118,    -30,     69,
       158,    214,    222,    177,     88,    -29,   -145,   -235,   -273,   -249,   -163,    -32,    116,    247,    328,    337,
       264,    122,    -62,   -247,   -389,   -450,   -407,   -260,    -33,    227,    462,    613,    632,    496,    216,   -165,
      -571,   -910,  -1088,  -1025,   -674,    -34,    849,   1886,   2952,   3912,   4636,   5025
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_10000[] = {
        27,    -34,    -30,    -18,      1,     17,     17,     -1,    -22,    -25,     -6,     22,     32,     14,    -20,    -40,
       -25,     14,     46,     38,     -6,    -49,    -52,     -7,     50,     67,     24,    -45,    -81,    -45,     35,     92,
        70,    -19,    -99,    -96,     -5,    100,    123,     36,    -93,   -149,    -74,     76,    170,    118,    -48,   -186,
      -166,      7,    191,    217,     47,   -183,   -268,   -115,    159,    316,    198,   -115,   -356,   -295,     45,    384,
       407,     55,   -393,   -535,   -196,    377,    684,    394,   -321,   -863,   -685,    199,   1105,   1162,     60,  -1514,
     -2178,   -770,   2717,   6906,   9748
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_15000[] = {
        58,     -6,    -42,    -11,     46,     17,    -62,    -40,     64,     58,    -73,    -92,     66,    121,    -60,   -164,
        35,    201,     -5,   -245,    -47,    280,    109,   -314,   -197,    332,    300,   -339,   -431,    318,    584,   -269,
      -776,    171,   1008,     -7,  -1320,   -279,   1777,    815,  -2643,  -2180,   5541,  14045
};

static const int16_t adrv904x_cduc_coefs_lte_fs_30720_ibw_20000[] = {
        50,    -52,    -36,     59,    -38,    -72,     99,     -5,   -138,    123,     66,   -221,    108,    187,   -303,     27,
       360,   -349,   -150,    573,   -313,   -455,    804,   -124,   -944,   1020,    358,  -1786,   1189,   1682,  -4038,   1282,
     17378
};

static const int16_t adrv904x_cduc_coefs_lte_fs_7680_ibw_5000[] = {
        50,    -52,    -36,     59,    -38,    -72,     99,     -5,   -138,    123,     66,   -221,    108,    187,   -303,     27,
       360,   -349,   -150,    573,   -313,   -455,    804,   -124,   -944,   1020,    358,  -1786,   1189,   1682,  -4038,   1282,
     17378
};

static const int16_t adrv904x_cduc_coefs_lte_iot_fs_15360_ibw_10000[] = {
       -38,     23,     15,     -3,     14,     13,     -9,      9,     14,    -13,      4,     17,    -15,     -1,     20,    -15,
        -6,     24,    -14,    -12,     27,    -11,    -19,     30,     -7,    -26,     31,     -1,    -33,     31,      7,    -40,
        29,     17,    -47,     24,     28,    -52,     17,     40,    -55,      7,     52,    -55,     -6,     64,    -52,    -21,
        75,    -46,    -38,     84,    -35,    -57,     90,    -21,    -77,     92,     -1,    -97,     90,     22,   -115,     82,
        49,   -131,     67,     79,   -144,     46,    111,   -150,     18,    144,   -150,    -17,    176,   -142,    -59,    206,
      -125,   -107,    231,    -96,   -160,    250,    -56,   -219,    260,     -2,   -280,    259,     66,   -343,    243,    151,
      -406,    209,    254,   -467,    151,    380,   -524,     62,    536,   -576,    -71,    737,   -621,   -278,   1019,   -658,
      -626,   1480,   -685,  -1353,   2520,   -701,  -4121,   9364,  21138
};

static const int16_t adrv904x_cduc_coefs_lte_iot_fs_30720_ibw_20000[] = {
        34,    -35,    -19,     10,    -18,    -16,     22,    -11,    -22,     29,     -5,    -31,     32,      5,    -41,     32,
        17,    -52,     29,     33,    -62,     20,     51,    -69,      6,     72,    -72,    -15,     94,    -68,    -42,    114,
       -57,    -74,    130,    -36,   -111,    140,     -4,   -151,    141,     39,   -191,    130,     93,   -227,    103,    157,
      -257,     59,    231,   -275,     -7,    311,   -275,    -97,    396,   -253,   -214,    481,   -200,   -364,    564,   -104,
      -556,    640,     55,   -814,    706,    321,  -1191,    758,    814,  -1873,    795,   2075,  -3943,    814,  17643
};

static const int16_t adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_100000[] = {
       -86,     35,    -29,     13,      9,    -33,     52,    -62,     59,    -44,     23,     -2,    -12,     16,     -7,    -10,
        29,    -43,     46,    -36,     16,      9,    -28,     37,    -30,     10,     16,    -40,     52,    -47,     26,      4,
       -34,     52,    -51,     32,      1,    -36,     60,    -64,     46,    -11,    -30,     62,    -73,     58,    -21,    -25,
        65,    -84,     74,    -37,    -15,     64,    -93,     89,    -53,     -4,     62,   -102,    106,    -73,     12,     57,
      -109,    124,    -96,     31,     48,   -114,    142,   -121,     55,     34,   -116,    161,   -150,     84,     15,   -115,
       179,   -182,    120,    -10,   -110,    197,   -218,    162,    -44,    -98,    214,   -259,    214,    -88,    -79,    229,
      -307,    279,   -147,    -49,    243,   -365,    363,   -228,     -3,    256,   -439,    480,   -347,     70,    266,   -545,
       658,   -539,    198,    274,   -725,    985,   -918,    474,    279,  -1152,   1867,  -2098,   1515,    282,  -4311,  19925
};

static adi_adrv904x_ErrAction_e cddc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel, 
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps);

static adi_adrv904x_ErrAction_e cduc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps);

static uint32_t adrv904x_SampleRateJesdIqRatioCalculate(const uint32_t sampleRate_kHz)
{
    uint32_t samplingRatio = 1U; /* This is default for most cases */
    uint32_t interpolationRatio = 0U;

    if (sampleRate_kHz != 0U)
    {
        samplingRatio = sampleRate_kHz < ADRV904X_JESD_IQ_RATE_KHZ ?
                            ADRV904X_JESD_IQ_RATE_KHZ / sampleRate_kHz : 1U;

        /* Convert to log */
        while (samplingRatio > 1U)
        {
            interpolationRatio++;
            samplingRatio >>= 1U;
        }
    }

    return interpolationRatio;
}

static uint32_t adrv904x_CarrierBandSampleRateRatioCalculate(const uint32_t bandSampleRate_kHz, const uint32_t carrierSampleRate_kHz)
{
    uint32_t samplingRatio = 0U; /* This is default for most cases */
    uint32_t decimationRatio = 0U;

    if (carrierSampleRate_kHz == 0U)
    {
        return decimationRatio;
    }

    samplingRatio = bandSampleRate_kHz;
    samplingRatio /= carrierSampleRate_kHz;
    samplingRatio >>= 1U;
    
    while (samplingRatio > 0U)
    {
        decimationRatio++;
        samplingRatio >>= 1U;
    }
    
    return decimationRatio;
}

static uint32_t adrv904x_CarrierRateCalculate(const uint32_t hsDigRate_kHz, const uint32_t carrierSampleRate_kHz)
{
    uint32_t clkRatio = 0U;
    uint32_t carrierRateRatio = 0U;

    if (carrierSampleRate_kHz == 0U)
    {
        return carrierRateRatio;
    }

    clkRatio = hsDigRate_kHz / carrierSampleRate_kHz;
    carrierRateRatio = 0U;

    while (clkRatio > 1U)
    {
        carrierRateRatio++;
        clkRatio >>= 1U;
    }

    return carrierRateRatio;
}

static void swap(uint16_t* const a, uint16_t* const b)
{
    uint16_t tmp = *a;

    *a = *b;
    *b = tmp;
}


static adi_adrv904x_ErrAction_e adrv904x_CarrierJesdSlotTableCalculate( adi_adrv904x_Device_t* const                        device,
                                                                        const adi_adrv904x_CarrierRadioCfg_t* const         carrierConfigs,
                                                                        adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint16_t indexMap[ADI_ADRV904X_MAX_CARRIERS];
    uint16_t ratios[ADI_ADRV904X_MAX_CARRIERS];
    uint16_t count[ADI_ADRV904X_MAX_CARRIERS];
    uint32_t carrierIdx = 0U;
    uint32_t altCarrierIdx = 0U;
    uint32_t i = 0U;
    uint8_t valid = 0U;
    uint8_t assigned = 0U;
    uint64_t mask = 1U;
    uint32_t minIdx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    ADI_LIBRARY_MEMSET(indexMap, 0, sizeof(indexMap));
    ADI_LIBRARY_MEMSET(ratios, 0, sizeof(ratios));
    ADI_LIBRARY_MEMSET(count, 0, sizeof(count));

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        indexMap[carrierIdx] = carrierIdx; /* Index map */
        
        if (carrierConfigs->carriers[carrierIdx].sampleRate_kHz != 0U)
        {
            ratios[carrierIdx] = carrierConfigsOut->internalJesdCfg.frequencyKhz / carrierConfigs->carriers[carrierIdx].sampleRate_kHz;
            count[carrierIdx] = 0U;
        }
        else
        {
            ratios[carrierIdx] = ADRV904X_SLOT_TABLE_UNUSED;
            count[carrierIdx] = ADRV904X_SLOT_TABLE_UNUSED;
        }
    }

    for (carrierIdx = 0U; carrierIdx < (ADI_ADRV904X_MAX_CARRIERS - 1U); carrierIdx++)
    {
        minIdx = carrierIdx;
        for (altCarrierIdx = carrierIdx + 1U; altCarrierIdx < ADI_ADRV904X_MAX_CARRIERS; altCarrierIdx++)
        {
            if (ratios[altCarrierIdx] < ratios[minIdx])
            {
                minIdx = altCarrierIdx;
            }
        }

        /* Swap */
        swap(&ratios[minIdx], &ratios[carrierIdx]);
        swap(&count[minIdx], &count[carrierIdx]);
        swap(&indexMap[minIdx], &indexMap[carrierIdx]);
    }

    /* Build Slot Table. Start from clean slate */
    carrierConfigsOut->internalJesdCfg.slotValid = 0U;
    
    for (i = 0U; i < carrierConfigsOut->internalJesdCfg.numSlots; i++)
    {
        valid = ADI_FALSE;
        assigned = ADI_FALSE;

        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if (count[carrierIdx] == 0U)
            {
                if (assigned == ADI_FALSE)
                {
                    carrierConfigsOut->internalJesdCfg.slotTable[i] = indexMap[carrierIdx];
                    count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx];                  /* increment the count for the carrier */
                    valid = (carrierConfigs->carriers[indexMap[carrierIdx]].enable > 0U);
                    assigned = ADI_TRUE;
                }
            }
            else
            {
                count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx]; /* increment the count for the carrier */
            }
        }

        if (valid == ADI_TRUE)
        {
            carrierConfigsOut->internalJesdCfg.slotValid |= mask; /* set valid bit associated with this slot. */
        }

        mask <<= 1U;
    }

    /*interface slot table */
    ADI_LIBRARY_MEMSET(indexMap, 0, sizeof(indexMap));
    ADI_LIBRARY_MEMSET(ratios, 0, sizeof(ratios));
    ADI_LIBRARY_MEMSET(count, 0, sizeof(count));

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        indexMap[carrierIdx] = carrierIdx; /* Index map */
        if (carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz != 0U)
        {
            ratios[carrierIdx] = carrierConfigsOut->internalJesdCfg.frequencyKhz / carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz;
            count[carrierIdx] = 0U;
        }
        else
        {
            ratios[carrierIdx] = ADRV904X_SLOT_TABLE_UNUSED;
            count[carrierIdx] = ADRV904X_SLOT_TABLE_UNUSED;
        }
    }

    for (carrierIdx = 0U; carrierIdx < (ADI_ADRV904X_MAX_CARRIERS - 1U); carrierIdx++)
    {
        minIdx = carrierIdx;
        for (altCarrierIdx = carrierIdx + 1U; altCarrierIdx < ADI_ADRV904X_MAX_CARRIERS; altCarrierIdx++)
        {
            if (ratios[altCarrierIdx] < ratios[minIdx])
            {
                minIdx = altCarrierIdx;
            }
        }

        /* Swap */
        swap(&ratios[minIdx], &ratios[carrierIdx]);
        swap(&count[minIdx], &count[carrierIdx]);
        swap(&indexMap[minIdx], &indexMap[carrierIdx]);
    }

    /* Calculate f_jesd/f_jesd_sample_rate ratio for each carrier after reordering based on sample rate */
    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
            if (carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz != 0U)
            {
                ratios[carrierIdx] = carrierConfigsOut->internalJesdCfg.frequencyKhz / carrierConfigs->carriers[indexMap[carrierIdx]].sampleRate_kHz;
                count[carrierIdx] = 0U;
            }
        }

    for (i = 0U; i < carrierConfigsOut->internalJesdCfg.ifaceMaxSlot; i++)
    {
        /* Reinitialize before start of new slot table calculation */
        assigned = ADI_FALSE;

        for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
        {
            if (count[carrierIdx] == 0U)
            {
                if (assigned == ADI_FALSE)
                {
                    carrierConfigsOut->internalJesdCfg.ifaceSlotTable[i] = indexMap[carrierIdx];
                    count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx]; /* increment the count for the carrier */
                    assigned = ADI_TRUE;
                }
            }
            else
            {
                count[carrierIdx] = (count[carrierIdx] + 1U) % ratios[carrierIdx]; /* increment the count for the carrier */
            }
            
            carrierConfigsOut->internalJesdCfg.dummyIfaceSlotsRemoved[carrierIdx] = 0u;
        }

        mask <<= 1U; /* Shift mask bit. */
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}


ADI_API adi_adrv904x_ErrAction_e adrv904x_CalculateRxSampleXbarSlotConfig(  adi_adrv904x_Device_t* const                    device,
                                                                            const adi_adrv904x_CarrierJesdCfg_t* const      inJesdCfg,
                                                                            adi_adrv904x_CarrierReconfigOutput_t* const     out)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint16_t carrierIdx = 0U;
    uint16_t sampleIdx = 0U;
    uint32_t mask = 0U;
    uint16_t iqFlag = 0U;
    uint32_t m = 0U;
    uint32_t linkIdx = 0U;
    uint16_t slotIdx = 0U;
    uint32_t i = 0U;
    uint16_t tmp = 0U;
    uint16_t subFrame = 0U;
    uint16_t subFrameDepth = 0U;
    uint16_t lane = 0U;
    uint16_t laneDepth = 0U;
    uint16_t jesdL = 0U;
    uint16_t profIdx = 0U;
    uint16_t mReal = 0U;
    
    adi_adrv904x_JesdComponentCarrierXbarOutput_t tempSlot[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint32_t slotMapped[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, inJesdCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, out);

    ADI_LIBRARY_MEMSET(&tempSlot, 0, sizeof(tempSlot));
    ADI_LIBRARY_MEMSET(&slotMapped, 0, sizeof(slotMapped));

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    { 
        mReal = device->initExtract.jesdSetting.framerSetting[linkIdx].jesdM * ADRV904X_JESD_INT_INTERLEAVING_RATIO;
        for (m = 0U; m < ADI_ADRV904X_MAX_CARRIER_SLOTS; m++)
        {
            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect = inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect;
            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].channelSelect = inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect;
            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
            
            /* break loop iteration if converter index is unused. */
            if (out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
            {
                break;
            }
            
            carrierIdx = out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect >> 1U;
            iqFlag = out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect % 2U;
            profIdx = device->initExtract.chanAssign[out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].channelSelect];
            sampleIdx = 0U;

            if (profIdx == 255U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT( &device->common,
                                        recoveryAction,
                                        linkIdx,
                                        "Framer sample XBAR mapped to an unconfigured CDDC.");
                return recoveryAction;
            }


            /* Should we check for unused channels for error checking ? */
            if (carrierIdx < ADI_ADRV904X_MAX_CARRIERS)
            {
                mask = 1U << ((inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect << 1U) + iqFlag);

                for (slotIdx = 0U; slotIdx < out->profileCfgs[profIdx].internalJesdCfg.ifaceMaxSlot; slotIdx++)
                {
                    if (out->profileCfgs[profIdx].internalJesdCfg.ifaceSlotTable[slotIdx] == carrierIdx)
                    {
                        if ((sampleIdx                      == inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].sampleSelect) &&
                            ((mask & slotMapped[slotIdx])   == 0U))
                        {
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect = (adi_adrv904x_JesdComponentCarrierXbar_e)((slotIdx << 1U) + iqFlag);
                            slotMapped[slotIdx] |= mask;
                            break;
                        }
                        else
                        {
                            sampleIdx++;
                        }
                    }
                }

                if (out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
                {
                    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Framer %d sample XBAR[%d] not mapped to a CDDC iface slot.", linkIdx, m);
                    
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    ADI_PARAM_ERROR_REPORT( &device->common,
                                            recoveryAction,
                                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect,
                                            "Incomplete input carrier crossbar. Must assign all valid slots.");
                    return recoveryAction;
                }

                recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
            }
        }

        if ((device->initExtract.framerInterleaveMode[linkIdx]              ==  ADI_TRUE) && 
            (device->initExtract.jesdSetting.framerSetting[linkIdx].jesdM   >   0U))
        {
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

            ADI_LIBRARY_MEMCPY(tempSlot, out->jesdCfg.linkCfg[linkIdx].jesdCfg, mReal * sizeof(adi_adrv904x_JesdComponentCarrierXbarOutput_t));
            
            jesdL = 0U;
            for (i = 0U; i < ADI_ADRV904X_MAX_SERIALIZER_LANES; i++)
            {
                if (((device->initExtract.jesdSetting.framerSetting[linkIdx].serialLaneEnabled >> i) & 0x1U) > 0U)
                {
                    jesdL++;
                }
            }

            if (jesdL == 0U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, jesdL, "Invalid Configuration Parameter");
                return recoveryAction;
            }

            subFrameDepth = device->initExtract.jesdSetting.framerSetting[linkIdx].jesdM / jesdL;
            laneDepth = subFrameDepth * ADRV904X_JESD_INT_INTERLEAVING_RATIO;

            if ((subFrameDepth == 0U) || (laneDepth == 0U))
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, subFrameDepth, "Invalid subFrameDepth or laneDepth Parameters");
                return recoveryAction;
            }

            for (i = 0U; i < mReal; i++)
            {
                /* calculate actual virtual converter index output in this slot */
                tmp = (i % subFrameDepth);                                          /* calculate location in subframe row */
                subFrame = ((i % laneDepth) / subFrameDepth);                       /* perform intermediate scaling required for current lane and subframe calculations. */
                lane = (i / laneDepth);                                             /* calculate current lane of the subframe output */
                tmp += (lane * subFrameDepth);
                tmp *= ADRV904X_JESD_INT_INTERLEAVING_RATIO;
                tmp += subFrame;

                /* Assign the sample XBAR values for the actual output sample to this index */
                out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].channelSelect = tempSlot[i].channelSelect;
                out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierSelect = tempSlot[i].carrierSelect;
                out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].slotSelect    = tempSlot[i].slotSelect;
            }

            recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
        }
    }

    return recoveryAction;
}


ADI_API adi_adrv904x_ErrAction_e adrv904x_CalculateTxSampleXbarSlotConfig(  adi_adrv904x_Device_t* const                    device,
                                                                            const adi_adrv904x_CarrierJesdCfg_t* const      inJesdCfg,
                                                                            adi_adrv904x_CarrierReconfigOutput_t* const     out)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint16_t carrierIdx = 0U;
    uint16_t sampleIdx = 0U;
    uint32_t mask = 0U;
    uint16_t iq = 0U;
    uint16_t slotIdx = 0U;
    uint32_t m = 0U;
    uint32_t linkIdx = 0U;
    uint32_t i = 0U;
    uint32_t j = 0U;
    uint16_t tmp = 0U;
    uint16_t subFrame = 0U;
    uint16_t subFrameDepth = 0U;
    uint16_t lane = 0U;
    uint16_t jesdL = 0U;
    uint16_t numRows = 0U;
    uint16_t numColumns = 0U;
    uint16_t convIdx = 0U;
    uint16_t index = 0U;
    uint16_t profIdx = 0U;
    uint8_t jesdM = 0U;
    uint16_t mReal = 0U;
    
    uint32_t slotMapped[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    adi_adrv904x_JesdComponentCarrierXbarOutput_t tempSlot[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint16_t ipOrdering[ADI_ADRV904X_MAX_CARRIER_SLOTS];
    uint16_t xbarOrdering[ADI_ADRV904X_MAX_CARRIER_SLOTS];

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, inJesdCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, out);

    ADI_LIBRARY_MEMSET(&slotMapped, 0, sizeof(slotMapped));
    ADI_LIBRARY_MEMSET(&tempSlot, 0, sizeof(tempSlot));
    ADI_LIBRARY_MEMSET(&ipOrdering, 0, sizeof(ipOrdering));
    ADI_LIBRARY_MEMSET(&xbarOrdering, 0xFF, sizeof(xbarOrdering));

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    {
        jesdM = device->initExtract.jesdSetting.deframerSetting[linkIdx].jesdM;
        mReal = jesdM * ADRV904X_JESD_INT_INTERLEAVING_RATIO;
        convIdx = 0U;
        
        for (m = 0U; m < ADI_ADRV904X_MAX_CARRIER_SLOTS; m++)
        {
            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect = inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].carrierSelect;
            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].channelSelect = inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect;
            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;

            /* break loop iteration if converter index is unused. */
            if (out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
            {
                break;
            }

            carrierIdx = out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect >> 1U;
            iq = out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].carrierSelect % 2U;
            profIdx = device->initExtract.chanAssign[out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].channelSelect];
            sampleIdx = 0U;
            
            if (profIdx == 255U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT( &device->common,
                    recoveryAction,
                    linkIdx,
                    "Deframer sample XBAR mapped to an unconfigured CDUC.");
                return recoveryAction;
            }

            /* Should we check for unused channels for error checking ? */
            if (carrierIdx < ADI_ADRV904X_MAX_CARRIERS)
            {
                mask = 1U << ((inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].channelSelect << 1) + iq);

                for (slotIdx = 0; slotIdx < out->profileCfgs[profIdx].internalJesdCfg.ifaceMaxSlot; slotIdx++)
                {
                    if (out->profileCfgs[profIdx].internalJesdCfg.ifaceSlotTable[slotIdx] == carrierIdx)
                    {
                        if ((sampleIdx                      == inJesdCfg->linkCfg[linkIdx].carrierXbarCfg[m].sampleSelect) &&
                            ((mask & slotMapped[slotIdx])   == 0U))
                        {
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect = (adi_adrv904x_JesdComponentCarrierXbar_e)((slotIdx << 1U) + iq);
                            slotMapped[slotIdx] |= mask;
                            break;
                        }
                        else
                        {
                            sampleIdx++;
                        }
                    }
                }

                if (out->jesdCfg.linkCfg[linkIdx].jesdCfg[m].slotSelect == ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR)
                {
                    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Deframer %d sample XBAR[%d] not mapped to a CDUC iface slot.", linkIdx, m);
                    
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, "Incomplete input carrier crossbar. Must assign all valid slots.");
                    return recoveryAction;
                }

                recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
            }
        }

        if ((device->initExtract.deframerInterleaveMode[linkIdx]            ==  ADI_TRUE) &&
            (device->initExtract.jesdSetting.deframerSetting[linkIdx].jesdM >   0U))
        {
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

            if ((mReal * sizeof(adi_adrv904x_JesdComponentCarrierXbarOutput_t)) > sizeof(tempSlot))
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, mReal, "Invalid Configuration Parameter");
                return recoveryAction;
            }

            ADI_LIBRARY_MEMCPY(tempSlot, out->jesdCfg.linkCfg[linkIdx].jesdCfg, mReal * sizeof(adi_adrv904x_JesdComponentCarrierXbarOutput_t));
            
            jesdL = 0U;
            for (i = 0U; i < ADI_ADRV904X_MAX_DESERIALIZER_LANES; i++)
            {
                if (((device->initExtract.jesdSetting.deframerSetting[linkIdx].deserialLaneEnabled >> i) & 0x1U) > 0U)
                {
                    jesdL++;
                }
            }
            
            if (jesdL == 0U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, jesdL, "Invalid Configuration Parameter");
                return recoveryAction;
            }

            subFrameDepth = jesdM / jesdL;

            if (subFrameDepth == 0U)
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, subFrameDepth, "Invalid Configuration Parameter");
                return recoveryAction;
            }
            
            for (i = 0U; i < mReal; i++)
            {
                /* calculate actual virtual converter index output in this slot */
                tmp = (i % subFrameDepth);                                          /* calculate location in subframe row */
                subFrame = (i / subFrameDepth);                                     /* perform intermediate scaling required for current lane and subframe calculations. */
                lane = (subFrame % jesdL);                                          /* calculate current lane of the subframe output */
                subFrame /= jesdL;                                                  /* final calculation to determine which subframe is active */
                tmp += ((lane * mReal) / jesdL);
                tmp += (subFrame * subFrameDepth);
                ipOrdering[i] = tmp;
            }

            numColumns = ADRV904X_JESD_XBAR_NUM_COLUMNS;
            numRows = mReal / numColumns;
            numRows += ((mReal % numColumns) > 0U) ? 1U : 0U;

            for (subFrame = 0U; subFrame < ADRV904X_JESD_INT_INTERLEAVING_RATIO; subFrame++)
            {
                index = 0U;

                for (j = 0U; j < numRows; j++)
                {
                    for (i = 0U; i < ADRV904X_JESD_INT_INTERLEAVING_RATIO; i++)
                    {
                        tmp = (j * numColumns) + (subFrame * 4U) + i;

                        if (index < jesdM)
                        {
                            xbarOrdering[tmp] = ipOrdering[convIdx];
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].channelSelect = tempSlot[ipOrdering[convIdx]].channelSelect;
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierSelect = tempSlot[ipOrdering[convIdx]].carrierSelect;
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].slotSelect    = tempSlot[ipOrdering[convIdx]].slotSelect;
                            convIdx++;
                        }
                        else
                        {
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].channelSelect = 0U;
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].carrierSelect = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
                            out->jesdCfg.linkCfg[linkIdx].jesdCfg[tmp].slotSelect    = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
                        }
                        index++;
                    }
                }
            }

            recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
        }
    }

    return recoveryAction;
}

/* Helper function to convert val_cc --> calc_ns (properly rounded to nearest 1ns) using jesd ratio log2 and jesd freq using only integer math */
static uint32_t convert_cc_to_ns(uint32_t val_cc, uint32_t clkToJesdRatioLog2, uint32_t jesdFrequency_kHz)
{
    uint32_t ret = 0u;

    /* Cast to uint64_t to prevent overflow of 32bit reg after multiplication */
    uint64_t calc = (uint64_t)val_cc;
    
    /* Scale by 2 for rounding purposes */
    calc = calc << 1u;

    /* Scale to ns per hsdigclk cc */
    calc *= (1000000u >> clkToJesdRatioLog2);
    calc /= jesdFrequency_kHz;

    /* Complete rounding  operation */
    calc += 1u;
    calc >>= 1u;

    /* cast back 32bit to return */
    ret = (uint32_t)calc;

    return (ret);
}

/**
* \brief Final delay calculation. Accumulates all internal delay calculations and combines into the device delay configurations written to part
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \pre adrv904x_CducDelayCalculate
* \pre adrv904x_CddcDelayCalculate
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in,out] carrierConfigs holds the user selected values for reconfiguration
* \param[in,out] carrierConfigsOut holds the calculated values during reconfiguration
* \param[in,out] prms delay configuration written to part
*
* \retval adi_adrv904x_ErrAction_e - ADI_ADRV904X_ERR_ACT_NONE if Successful
*/

static adi_adrv904x_ErrAction_e adrv904x_CalculateCommonDelayParameters(adi_adrv904x_Device_t* const                                device,
                                                                        const adi_adrv904x_CarrierRadioCfg_t* const                 carrierConfigsIn,
                                                                        const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    carrierConfigsOut,
                                                                        adi_adrv904x_CarrierDelayParameters_t* const                prms)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    int diff_max = INT16_MIN;
    int diff_min = INT16_MAX;
    
    uint8_t compensation_used = 0u;
    uint16_t tmp = 0u;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsIn);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);

    /* Clear hw delay config settings */
    ADI_LIBRARY_MEMSET(&prms->bufferCfg, 0, sizeof(adi_adrv904x_CarrierHwDelayBufferConfig_t));
    
    /* Calculate number of carrier samples to add to get close to target, total delays after adding buffers, and remaining delay errors */
    for (int i = 0; i < prms->noOfCarriers; i++)
    {
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0)
        {
            compensation_used = 1u;
            if (compensation_used == 1u)
            {
                tmp = prms->uncompOffset_cc[i];
                tmp <<= 1u;
                tmp /= prms->carrSamplePeriod_cc[i];
                tmp += 1u;
                tmp >>= 1u;
                prms->compIntSamples[i] = tmp;
            }
            else
            {
                prms->compIntSamples[i] = 0u;
            }

            /* Calculate compensation in cc's */
            prms->comp_cc[i] = prms->compIntSamples[i] * prms->carrSamplePeriod_cc[i];

            /* Calculate final total delay in cc's: Combined group delay + Actual DelayBufferCompensation Offsets added */
            prms->finalDelayTotal_cc[i] = prms->groupDelayComb_cc[i] + prms->comp_cc[i];

            /* Calculate final delay in the CDUC/CDDC only, removing group delay attributed to BandDUC/BandDDC
             * This will be Carrier Grp Delay + Actual DelayBuffer Offsets
             */
            prms->finalDelayCarr_cc[i] = prms->finalDelayTotal_cc[i] - prms->groupDelayBand_cc[i];

            /* Calculate delayDiffPerCarrier_cc (the leftover error between this carrier's target vs. actual total delay) */
            prms->delayDiffPerCarrier_cc[i] = (int16_t)prms->targetDelay_cc[i] - (int16_t)prms->finalDelayTotal_cc[i];

            /* Update diff max/min */
            diff_max = (prms->delayDiffPerCarrier_cc[i] > diff_max) ? prms->delayDiffPerCarrier_cc[i] : diff_max;
            diff_min = (prms->delayDiffPerCarrier_cc[i] < diff_min) ? prms->delayDiffPerCarrier_cc[i] : diff_min;

            /* Convert final delays from cc --> ns and store */
            prms->finalDelayTotal_ns[i] = convert_cc_to_ns(prms->finalDelayTotal_cc[i], prms->clkToJesdRatioLog2, prms->jesdFrequency_kHz);
            prms->finalDelayCarr_ns[i] =  convert_cc_to_ns(prms->finalDelayCarr_cc[i], prms->clkToJesdRatioLog2, prms->jesdFrequency_kHz);
        }
    }

    /* Calculate total delay mismatch between any 2 carriers = diff_max - diff_min */
    prms->delayMismatch_cc = (diff_max - diff_min);

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}


static uint32_t filterDelay(uint16_t tap_count,
                            uint32_t clkPeriod)
{
    /* calculate numerator */
    uint32_t delay = 0;
    delay = tap_count - 1u;
    delay *= clkPeriod;
    /* scale numerator by 2 for rounding purposes */
    delay <<= 1u;
    /* Divide */
    delay /= 2u;
    /* complete the rounding operation */
    delay += 1u;
    delay >>= 1u;
    
    return delay;
}

/* channel filter pipeline delay */

static uint32_t cfiltPipeDelay( uint8_t bypass,
                                uint32_t jesdClkPeriod,
                                uint16_t end_bank,
                                uint32_t carr_clk_period)
{
    const uint16_t  NO_OF_CHAN_FILTER_8_TAP_DATA_PIPES  = 17u;
    const uint16_t  NO_OF_CHAN_FILTER_16_TAP_DATA_PIPES = 30u;
    const uint16_t  CHAN_FILTER_PIPELINE_DELAY_DIVISOR = 6u;
    
    uint32_t accum_max_count;
    uint32_t accum_delay;
    uint32_t delay;

    if (bypass > 0u)
    {
        return jesdClkPeriod;
    }

    if (end_bank <= NO_OF_CHAN_FILTER_8_TAP_DATA_PIPES)
    {
        accum_max_count = 8u;
    }
    else if (end_bank <= (NO_OF_CHAN_FILTER_8_TAP_DATA_PIPES + NO_OF_CHAN_FILTER_16_TAP_DATA_PIPES))
    {
        accum_max_count = 16u;
    }
    else
    {
        accum_max_count = 32u;
    }

    accum_delay = (accum_max_count < carr_clk_period) ? accum_max_count : carr_clk_period;

    delay = accum_delay + (((end_bank - 1u) / CHAN_FILTER_PIPELINE_DELAY_DIVISOR) * jesdClkPeriod) + 4u + (jesdClkPeriod << 1u);

    return delay;
}

/* hb filter delay */

static uint32_t hbFilterDelay(  uint8_t num_hb,
                                uint32_t carr_clk_period)
{
    const uint32_t  CARRIER_GROUP_DELAY_HALF_BAND_DELAYS[] = { 35, 9, 7, 5, 5 };
    
    uint32_t dly = 0;
    for (uint8_t i = 0; i < num_hb; i++)
    {
        dly += CARRIER_GROUP_DELAY_HALF_BAND_DELAYS[i] * (carr_clk_period >> (i + 1));
    }
    return dly;
}

/* interleaver delay */

static uint32_t interleaverDelay(   uint8_t carr_slot, 
                                    uint32_t jesdClkPeriod)
{
    return (jesdClkPeriod * carr_slot);
}

/**
* \brief Calculates resource sharing block delay
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] carrierMask carrier mask
* \param[in] resourcePipe holds the calculated resource share configuration
* \param[in] jesdClkPeriod_cc jesd clk period in hsdigclk clock cycles
* \param[in] carrierNum the carrier to calculated for
*
* \retval delay Resource Share delay for the requested carrier
*/

static uint32_t resourceShareDelay( adi_adrv904x_Device_t* const                        device, 
                                    const adrv904x_CarrierResourceSharePrm_t * const    prms, 
                                    uint32_t                                            all_carr_enable, 
                                    uint32_t                                            jesdClkPeriod,
                                    uint8_t                                             carr_to_check)
{
    long int max_carr_period = 0;
    int carr_arrival_slot[ADI_ADRV904X_MAX_CARRIERS];
    int carr_slot_allocation[ADRV904X_NO_OF_RSD_CARRIER_SLOTS];
    int carr_slot_in[ADRV904X_NO_OF_RSD_CARRIER_SLOTS][ADI_ADRV904X_MAX_CARRIERS];
    int carr_slot_out[ADRV904X_NO_OF_RSD_CARRIER_SLOTS];
    int carr_first_in_slot[ADI_ADRV904X_MAX_CARRIERS];
    int carr_first_out_slot[ADI_ADRV904X_MAX_CARRIERS];
    long int carr_delay[ADI_ADRV904X_MAX_CARRIERS];
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);
    
    const uint8_t num_carr = prms->numCarriers;

    ADI_LIBRARY_MEMSET(&carr_arrival_slot, 0, sizeof(carr_arrival_slot));
    ADI_LIBRARY_MEMSET(&carr_slot_allocation, 0, sizeof(carr_slot_allocation));
    ADI_LIBRARY_MEMSET(&carr_slot_in, 0, sizeof(carr_slot_in));
    ADI_LIBRARY_MEMSET(&carr_slot_out, 0, sizeof(carr_slot_out));
    ADI_LIBRARY_MEMSET(&carr_first_in_slot, 0, sizeof(carr_first_in_slot));
    ADI_LIBRARY_MEMSET(&carr_first_out_slot, 0, sizeof(carr_first_out_slot));
    ADI_LIBRARY_MEMSET(&carr_first_out_slot, 0, sizeof(carr_first_out_slot));
    ADI_LIBRARY_MEMSET(&carr_delay, 0, sizeof(carr_delay));
    
    for (int i = 0; i < num_carr; i++)
    {
        if ((all_carr_enable & (1 << i)) > 0)
        {
            max_carr_period = (max_carr_period > (long int) prms->clkPeriod[i]) ? max_carr_period : (long int)prms->clkPeriod[i] ;
        }
    }
    int max_slots = max_carr_period / jesdClkPeriod;
    
    for (int i = 0; i < max_slots; i++)
    {
        carr_slot_allocation[i] = num_carr;
    }

    for (int i = 0; i < max_slots; i++)
    {
        for (int j = 0; j < num_carr; j++)
        {
            carr_slot_in[i][j] = 0;
        }
    }
    int slot_step_size = max_slots + 1;
    int first_enabled_carr = 1;
    int first_carr_num = 0;
    uint32_t min_carr_delay = UINT32_MAX;
    for (int i = 0; i < num_carr; i++)
    {
        if ((all_carr_enable & (1 << i)) > 0)
        {
            if (first_enabled_carr == 1)
            {
                min_carr_delay = prms->dlyPrev[i];
                first_enabled_carr = 0;
            }
            else
            {
                min_carr_delay = (min_carr_delay < prms->dlyPrev[i]) ? min_carr_delay : prms->dlyPrev[i];
            }
        }
    }
    first_enabled_carr = 1;
    for (int i = 0; i < num_carr; i++)
    {
        if ((min_carr_delay == prms->dlyPrev[i]) && (first_enabled_carr == 1))
        {
            first_carr_num = i;
            first_enabled_carr = 0;
        }
    }
    
    for (int i = 0; i < num_carr; i++)
    {
        if ((all_carr_enable & (1 << i)) > 0)
        {
            carr_arrival_slot[i] = ((int)(prms->dlyPrev[i] - prms->dlyPrev[first_carr_num]) / jesdClkPeriod) % max_slots;
            slot_step_size = prms->clkPeriod[i] / jesdClkPeriod;
        }
        else
        {
            carr_arrival_slot[i] = max_slots;
            slot_step_size = max_slots + 1;
        }
        /* allocating slots based on priority (lowest carrier highest priority) */
        int j = carr_arrival_slot[i];
        while (j >= 0) {
            j = j - slot_step_size;
        }
        
        j = j + slot_step_size;

        while (j < max_slots)
        {
            if (carr_slot_allocation[j] == num_carr)
            {
                carr_slot_allocation[j] = i;
                j = j + slot_step_size;
            }
            else
            {
                j = j + 1;
            }
        }

        /* arrival order */
        j = carr_arrival_slot[i];
        while (j >= 0)
        {
            j = j - slot_step_size;
        }
        
        j = j + slot_step_size;
        carr_first_in_slot[i] = j;
        
        while (j < max_slots)
        {
            carr_slot_in[j][i] = 1;
            j = j + slot_step_size;
        }
    }
    /* Rotating once due to delay difference between data and valids
     * int carr_slot_out[ADRV904X_NO_OF_RSD_CARRIER_SLOTS];
     */
    carr_slot_out[0] = carr_slot_allocation[max_slots - 1];
    for (int i = 1; i < max_slots; i++)
    {
        carr_slot_out[i] = carr_slot_allocation[i - 1];
    }
    
    for (int i = 0; i < num_carr; i++)
    {
        carr_first_out_slot[i] = max_slots;
        for (int j = 0; j < max_slots; j++)
        {
            if ((carr_slot_out[j] == i) && (carr_first_out_slot[i] > j))
            {
                carr_first_out_slot[i] = j;
            }
        }
    }
    
    for (int i = 0; i < num_carr; i++)
    {
        carr_delay[i] = (carr_first_out_slot[i] - carr_first_in_slot[i]) * jesdClkPeriod;
        if (carr_delay[i] < 0)
        {
            carr_delay[i] = carr_delay[i] + max_slots*jesdClkPeriod;
        }
        while (carr_delay[i] > (long int) prms->clkPeriod[i])
        {
            carr_delay[i] = carr_delay[i] - prms->clkPeriod[i];
        }
    }
    return (uint32_t)carr_delay[carr_to_check];
}

/* cddc hb slot_gen delay */

static uint32_t cddcHbSlotGenDelay( uint8_t  carr_to_check,
                                    uint32_t cddc_clk_period,
                                    uint32_t band_clk_period, 
                                    uint32_t pwrmeas_clk_period)
{
    uint32_t counter_delay;
    uint32_t data_pipe_delay;
    uint32_t slot_delay;

    counter_delay = ((carr_to_check % 4u) * cddc_clk_period);
    data_pipe_delay = pwrmeas_clk_period + 1;

    if (counter_delay < data_pipe_delay) 
    {
        slot_delay = counter_delay + band_clk_period - data_pipe_delay;
    }
    else 
    {
        slot_delay = counter_delay - data_pipe_delay;
    }

    return slot_delay;
}


static adi_adrv904x_ErrAction_e transferJesdConfigToOutputCfg(  adi_adrv904x_Device_t* const                            device,
                                                                adi_adrv904x_CarrierReconfigProfileCfgOut_t * const     pProfileCfgOut,
                                                                const adrv904x_CarrierJesdParameters_t * const          prms)
{
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pProfileCfgOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);
    
    pProfileCfgOut->internalJesdCfg.frequencyKhz = prms->frequency_kHz;
    pProfileCfgOut->internalJesdCfg.divide = prms->divide;
    pProfileCfgOut->internalJesdCfg.initSlot = prms->initSlot;
    pProfileCfgOut->internalJesdCfg.maxSlot = prms->maxSlot;
    pProfileCfgOut->internalJesdCfg.slotValid = prms->slotValid;
    pProfileCfgOut->internalJesdCfg.ifaceMaxSlot = prms->ifaceMaxSlot;

    for (int i = 0; i < (int)ADI_ADRV904X_MAX_TXCHANNELS; i++)
    {
        pProfileCfgOut->internalJesdCfg.dummyIfaceSlotsRemoved[i] = 0;
    }

    /* Taking the slot table as it is from configurator instead of making the invalid slots as 0 */
    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        if (i < (int)pProfileCfgOut->internalJesdCfg.maxSlot)
        {
            pProfileCfgOut->internalJesdCfg.slotTable[i] = prms->slotTable[i];
        }
        else
        {
            pProfileCfgOut->internalJesdCfg.slotTable[i] = (uint16_t)ADRV904X_SLOT_TABLE_UNUSED;
        }
    }

    for (int i = 0; i < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; i++)
    {
        pProfileCfgOut->internalJesdCfg.ifaceSlotTable[i] = prms->ifaceSlotTable[i];
    }
    return (ADI_ADRV904X_ERR_ACT_NONE);
}

/* Transfer shuffle prms structure --> profile config output structure */
static adi_adrv904x_ErrAction_e transferJesdConfigShuffleToJesd(adi_adrv904x_Device_t* const                        device,
                                                                adi_adrv904x_CarrierReconfigProfileCfgOut_t * const pProfileCfgOut, 
                                                                const adrv904x_SlotTableShuffleParams_t * const     prms)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint16_t iface_slot_valid[ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS];
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pProfileCfgOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);
    
    ADI_LIBRARY_MEMSET(iface_slot_valid, 0, sizeof(iface_slot_valid));

    /* Copy over carrier slot table and carrier valid array[64] to single 64bit word */
    pProfileCfgOut->internalJesdCfg.slotValid = 0u;
    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        if (prms->jesdSlotValid[i] > 0u)
        {
            pProfileCfgOut->internalJesdCfg.slotValid += (1ull << i);
        }

        pProfileCfgOut->internalJesdCfg.slotTable[i] = prms->jesdSlotTable[i];
    }

    /* Convert carrier slot table --> iface slot table */

    /* initialize cduc iface slot table to all ADRV904X_SLOT_TABLE_UNUSED and invalid */
    for (int i = 0u; i < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; i++)
    {

        pProfileCfgOut->internalJesdCfg.ifaceSlotTable[i] = ADRV904X_SLOT_TABLE_UNUSED;
        iface_slot_valid[i] = 0u;
    }

    /* Iterate through all carrier slots, and apply to iface table element [i % iface_size]. Check for overwrites */
    for (int i = 0u; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        int iface_idx = i % pProfileCfgOut->internalJesdCfg.ifaceMaxSlot;

        /* Check if carrier table slot a value other than UNUSED */
        if (prms->jesdSlotTable[i] != ADRV904X_SLOT_TABLE_UNUSED)
        {
            /* Carrier table has a valid entry at slot i. Check if associated iface table slot conflicts */
            if ((pProfileCfgOut->internalJesdCfg.ifaceSlotTable[iface_idx] != prms->jesdSlotTable[i]) &&
                (iface_slot_valid[iface_idx] == 1u) &&
                prms->jesdSlotValid[i] == 1u)
            {
                /* ERROR! iface table already allocated for a different carrier at [i % ifaceMaxSlots]! */
                ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, 
                    "ERROR: CDUC IFACE SLOT TABLE element %d cannot be allocated for more than one carrier slot. Check carriers %d and %d",
                    iface_idx,
                    pProfileCfgOut->internalJesdCfg.ifaceSlotTable[iface_idx],
                    prms->jesdSlotTable[i]);
                
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT( &device->common,
                    recoveryAction,
                    iface_idx,
                    "CDUC IFACE SLOT TABLE element error at iface_idx. Cannot be allocated for more than one carrier slot.");
                return recoveryAction;
            }

            pProfileCfgOut->internalJesdCfg.ifaceSlotTable[iface_idx] = prms->jesdSlotTable[i];
            iface_slot_valid[iface_idx] = prms->jesdSlotValid[i];
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}

/* Transfer Slot Table data into Shuffle Prms structure */

static adi_adrv904x_ErrAction_e transferSlotTableConfig(adi_adrv904x_Device_t* const                                device,
                                                        const adi_adrv904x_CarrierReconfigProfileCfgOut_t * const   pProfileCfgOut, 
                                                        adrv904x_SlotTableShuffleParams_t *const                    prms)
{
    uint64_t slot_valid_mask = 1u;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pProfileCfgOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);

    //* Create carriers enabled mask based on the sample rate to accomodate dummy carriers */
    prms->carriersEnabled = 0u;
    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        prms->carrierClkPeriod[i] = (1u << pProfileCfgOut->carrierCfgs.carrierRateRatio[i]);
        prms->carrierSlots[i] = 0;
        if (pProfileCfgOut->carrierCfgs.carrierEnable[i] > 0)
        {
            for (uint8_t s = 0u; s < ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; s++)
            {
                if (pProfileCfgOut->internalJesdCfg.slotTable[s] == i)
                {
                    prms->carrierSlots[i] = s;
                    break;
                }
            }
        }
    }

    prms->carriersEnabled = pProfileCfgOut->carriersEnabled;

    prms->jesdClkPeriod = 1u << pProfileCfgOut->internalJesdCfg.divide;
    prms->jesdMaxSlot = pProfileCfgOut->internalJesdCfg.maxSlot;
    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        prms->jesdSlotTable[i] = pProfileCfgOut->internalJesdCfg.slotTable[i];
    }
    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        prms->jesdSlotValid[i] = (pProfileCfgOut->internalJesdCfg.slotValid & slot_valid_mask) != 0;
        slot_valid_mask <<= 1u;
    }

    prms->ifaceMaxSlots = pProfileCfgOut->internalJesdCfg.ifaceMaxSlot;

    return (ADI_ADRV904X_ERR_ACT_NONE);
}


static adi_adrv904x_ErrAction_e transferDelayMismatch(  adi_adrv904x_Device_t* const                                device,
                                                        const adi_adrv904x_CarrierReconfigProfileCfgOut_t * const   pProfileCfgOut, 
                                                        adrv904x_SlotTableShuffleParams_t * const                   prms)
{
    int i = 0;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pProfileCfgOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);
    
    for (i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {   
        prms->carrierDelayMismatch[i] = pProfileCfgOut->delayCfg.delayDiffPerCarrier_cc[i];
    }
    
    return (ADI_ADRV904X_ERR_ACT_NONE);
}
                          

static adi_adrv904x_ErrAction_e removeDummyCarriers(    adi_adrv904x_Device_t* const                            device,
                                                        adi_adrv904x_CarrierReconfigProfileCfgOut_t * const     pProfileCfgOut)
{    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pProfileCfgOut);

    /* For shuffling algorithm purposes, remove dummy carrier slots (both iface and carrier slots)
     * They must be re-inserted to iface table after shuffling is finished to meet xbar sample expectations and avoid xbar setup failure
     */

    /* iface table removal */
    for (int s = 0; s < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; s++)
    {
        int cc = pProfileCfgOut->internalJesdCfg.ifaceSlotTable[s];
        if ((cc >= 0) &&
            (cc < (int)ADI_ADRV904X_MAX_CARRIERS) &&
            ((pProfileCfgOut->carriersEnabled & (1 << cc)) == 0))
        {
            /* If this cc is in range 0-7, appears in the slot table but not in the enabled mask, then its a dummy carrier
             * Remove it from table for now, increment counter of number slots removed for cc
             */
            pProfileCfgOut->internalJesdCfg.ifaceSlotTable[s] = ADRV904X_SLOT_TABLE_UNUSED;
            pProfileCfgOut->internalJesdCfg.dummyIfaceSlotsRemoved[cc]++;
        }
    }

    /* carrier table removal */
    for (int s = 0; s < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; s++)
    {
        int cc = pProfileCfgOut->internalJesdCfg.slotTable[s];
        if ((cc != ADRV904X_SLOT_TABLE_UNUSED) &&
            ((pProfileCfgOut->carriersEnabled & (1 << cc)) == 0))
        {
            /* If this cc is not in the enabled mask AND it appears in the slot table, then its a dummy carrier
             * Remove it from table for now
             */
            pProfileCfgOut->internalJesdCfg.slotTable[s] = ADRV904X_SLOT_TABLE_UNUSED;
        }
    }

    return (ADI_ADRV904X_ERR_ACT_NONE);
}


static adi_adrv904x_ErrAction_e reinsertDummyCarriers(  adi_adrv904x_Device_t* const                            device,
                                                        adi_adrv904x_CarrierReconfigProfileCfgOut_t * const     pProfileCfgOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pProfileCfgOut);

    /* For shuffling algorithm purposes, dummy carrier slots have to be marked as UNUSED temporarily
     * This function is to reinsert the required dummy carriers to first empty slots found
     */
    for (int cc = 0; cc < (int)ADI_ADRV904X_MAX_CARRIERS; cc++)
    {
        /* Check if We have dummy carrier (i.e. carrier sample rate > 0 and carrier is not enabled) */
        if ((pProfileCfgOut->internalJesdCfg.jesdSampleRate_kHz[cc] > 0u) &&
            ((pProfileCfgOut->carriersEnabled & (1 << cc)) == 0))
        {
            /* iface table: insert carrier  into first UNUSED slots found until all removed slots have been reinserted */
            int s = 0;
            while (
                (pProfileCfgOut->internalJesdCfg.dummyIfaceSlotsRemoved[cc] > 0) &&
                (s < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS))
            {
                if (pProfileCfgOut->internalJesdCfg.ifaceSlotTable[s] == ADRV904X_SLOT_TABLE_UNUSED)
                {
                    pProfileCfgOut->internalJesdCfg.ifaceSlotTable[s] = cc;
                    pProfileCfgOut->internalJesdCfg.dummyIfaceSlotsRemoved[cc]--;
                }

                s++;
            }

            /* Check if we ran out of empty iface slots before all dummies could be reinserted */
            if (pProfileCfgOut->internalJesdCfg.dummyIfaceSlotsRemoved[cc] != 0)
            {
                ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, 
                    "ERROR: Ran out of space to reinsert dummy carriers. Error occurred at carrier = %d",
                    cc);
                
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT( &device->common,
                    recoveryAction,
                    cc,
                    "ERROR: Ran out of space to reinsert dummy carriers");
                return recoveryAction;
            }
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}


static int calcDelayMismatch(   const adrv904x_SlotTableShuffleParams_t * const     slot_table_params,
                                int16_t * const                                     max_mismatch, 
                                int16_t * const                                     min_mismatch)
{
    *max_mismatch = slot_table_params->carrierDelayMismatch[0];
    *min_mismatch = slot_table_params->carrierDelayMismatch[0];
    for (int i = 1; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        if (*max_mismatch < slot_table_params->carrierDelayMismatch[i])
        {
            *max_mismatch = slot_table_params->carrierDelayMismatch[i];
        }
        if (*min_mismatch > slot_table_params->carrierDelayMismatch[i])
        {
            *min_mismatch = slot_table_params->carrierDelayMismatch[i];
        }
    }

    return (*max_mismatch - *min_mismatch);
}


static adi_adrv904x_ErrAction_e calcFirstCarrierSlot(   adi_adrv904x_Device_t* const                device,
                                                        adrv904x_SlotTableShuffleParams_t * const   slot_table_params)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, slot_table_params);
    
    for (int i = 0; i < 8; i++)
    {
        slot_table_params->carrierSlots[i] = 0;
        if (slot_table_params->carriersEnabled & (1 << i))
        {
            for (int j = 0; j < slot_table_params->jesdMaxSlot; j++)
            {
                if (slot_table_params->jesdSlotValid[j] == 1)
                {
                    if (slot_table_params->jesdSlotTable[j] == i)
                    {
                        slot_table_params->carrierSlots[i] = j;
                        break;
                    }
                }
            }
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}


static adi_adrv904x_ErrAction_e swapSimilarCarriers(adi_adrv904x_Device_t* const                device, 
                                                    adrv904x_SlotTableShuffleParams_t * const   slot_table_params)
{
    int jesd_to_carr_ratio;
    int exchange_done[ADI_ADRV904X_MAX_CARRIERS];
    int prev_min_diff[ADI_ADRV904X_MAX_CARRIERS];                           /* Has the carrier delay */
    int prev_min_diff_carr[ADI_ADRV904X_MAX_CARRIERS];                      /* Has the carrier number */
    int atleast_one_carr_found[ADI_ADRV904X_MAX_CARRIERS];
    int delay_diff_bw_cc[ADI_ADRV904X_MAX_CARRIERS][ADI_ADRV904X_MAX_CARRIERS];

    uint16_t carr_deinterleaver_slot_mod[ADI_ADRV904X_MAX_CARRIERS];        /* tmp table for swapped carrier first-slots */
    uint16_t tmp_table[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint16_t tmp_valid[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, slot_table_params);

    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        exchange_done[i] = 0;
        prev_min_diff_carr[i] = 0;
        carr_deinterleaver_slot_mod[i] = 0;
        for (int c = 0; c < (int)ADI_ADRV904X_MAX_CARRIERS; c++) {
            delay_diff_bw_cc[i][c] = 0;
        }
    }

    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        tmp_table[i] = slot_table_params->jesdSlotTable[i];
        tmp_valid[i] = 0u;
    }

    /* Re-ordering(swapping similar carr) slot table according to delay values */
    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++) {
        if (exchange_done[i] == 0) {
            carr_deinterleaver_slot_mod[i] = slot_table_params->carrierSlots[i];
        }
        prev_min_diff[i] = 256;
        atleast_one_carr_found[i] = 0;
        if ((slot_table_params->carriersEnabled & (1 << i)) && 
            (exchange_done[i] == 0) && 
            (abs(slot_table_params->carrierDelayMismatch[i]) > (ADRV904X_HALF_MAX_DELAY_CC / 2))) 
        {
            for (int j = 0; j < (int)ADI_ADRV904X_MAX_CARRIERS; j++) {
                if ((slot_table_params->carriersEnabled & (1 << j)) && 
                    (j != i) && 
                    (exchange_done[j] == 0)) 
                {
                    delay_diff_bw_cc[i][j] = slot_table_params->carrierDelayMismatch[i] + slot_table_params->carrierDelayMismatch[j];
                    if ((abs(delay_diff_bw_cc[i][j]) < prev_min_diff[i]) && 
                        (slot_table_params->carrierClkPeriod[i] == slot_table_params->carrierClkPeriod[j])) 
                    {
                        if (((slot_table_params->carrierDelayMismatch[i] > 0) && (slot_table_params->carrierSlots[j] > slot_table_params->carrierSlots[i])) || 
                            ((slot_table_params->carrierDelayMismatch[i] < 0) && (slot_table_params->carrierSlots[j] < slot_table_params->carrierSlots[i])) )
                        {
                            atleast_one_carr_found[i] = 1;
                            prev_min_diff[i] = abs(delay_diff_bw_cc[i][j]);
                            prev_min_diff_carr[i] = j;
                        }
                    }
                }
            }
            if (atleast_one_carr_found[i] == 1) {
                carr_deinterleaver_slot_mod[i] = slot_table_params->carrierSlots[prev_min_diff_carr[i]];
                carr_deinterleaver_slot_mod[prev_min_diff_carr[i]] = slot_table_params->carrierSlots[i];
                exchange_done[i] = 1;
                exchange_done[prev_min_diff_carr[i]] = 1;
            }
        }
    }

    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++) {
        if (slot_table_params->carriersEnabled & (1 << i))
        {
            jesd_to_carr_ratio = slot_table_params->carrierClkPeriod[i] / slot_table_params->jesdClkPeriod;
            for (int j = carr_deinterleaver_slot_mod[i]; j < slot_table_params->jesdMaxSlot; j = j + jesd_to_carr_ratio) {
                tmp_table[j] = i;
                tmp_valid[j] = 1;
            }
        }
    }

    /* Copy results to original structure */
    ADI_LIBRARY_MEMCPY(&slot_table_params->jesdSlotTable, &tmp_table, sizeof(tmp_table));
    ADI_LIBRARY_MEMCPY(&slot_table_params->jesdSlotValid, &tmp_valid, sizeof(tmp_valid));
    ADI_LIBRARY_MEMCPY(&slot_table_params->carrierSlots, &carr_deinterleaver_slot_mod, sizeof(carr_deinterleaver_slot_mod));

    return (ADI_ADRV904X_ERR_ACT_NONE);
}


static adi_adrv904x_ErrAction_e moveCarrierPositions(   adi_adrv904x_Device_t* const                device,
                                                        adrv904x_SlotTableShuffleParams_t * const   slot_table_params)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    uint16_t tmp_carrier_slots[ADI_ADRV904X_MAX_CARRIERS] = { 0u };
    uint16_t tmp_jesd_slot_table[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint16_t tmp_jesd_slot_valid_calc[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    int16_t  max_mismatch = 0u;
    int16_t  min_mismatch = 0u;
    int16_t  avg_mismatch = 0u;
    int16_t  delay_mismatch_rel[ADI_ADRV904X_MAX_CARRIERS] = { 0u };
    uint16_t jesd_to_carrier_ratio = 0u;
    uint16_t invalid_slot = 0u;
    uint16_t invalid_slot_found = 0u;
    uint16_t all_follow_slots_invalid = 0u;
    uint16_t iface_table_valid[ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS];
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, slot_table_params);

    /* Initialize tmp slot table and tmp valid arrays (size 64) with shuffle params values*/
    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        tmp_jesd_slot_table[i] = slot_table_params->jesdSlotTable[i];
        tmp_jesd_slot_valid_calc[i] = slot_table_params->jesdSlotValid[i];
    }

    /* Calculate average mismatch */
    calcDelayMismatch(slot_table_params, &max_mismatch, &min_mismatch);
    avg_mismatch = (max_mismatch + min_mismatch) / 2;

    /* For enabled carriers, Calc delay_mismatch_rel */
    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        if (slot_table_params->carriersEnabled & (1 << i))
        {
            delay_mismatch_rel[i] = slot_table_params->carrierDelayMismatch[i] - avg_mismatch;
            tmp_carrier_slots[i] = slot_table_params->carrierSlots[i];
        }
    }

    /* Iterate through carriers (i), searching for slots which are available to move carrier i into */
    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        /* Reset invalid_slot_found to 0 */
        invalid_slot_found = 0u;

        /* Copy original first slot to tmp first slot array */
        tmp_carrier_slots[i] = slot_table_params->carrierSlots[i];

        /* Clear tmp valid bits for all 16 iface slots */
        for (int s = 0; s < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; s++)
        {
            iface_table_valid[s] = 0;
        }

        /* Finding slots occupied by carriers in interface slot table eventhough it is not a valid slot in cduc slot table */
        for (int j = 0; j < (int)ADI_ADRV904X_MAX_CARRIERS; j++)
        {
            if (slot_table_params->carriersEnabled & (1 << j))
            {
                if (iface_table_valid[tmp_carrier_slots[j] % slot_table_params->ifaceMaxSlots])
                {
                    /* ERROR! iface table already allocated for a different carrier at [i % ifaceMaxSlots]! */
                    ADI_VARIABLE_LOG(&device->common,
                        ADI_HAL_LOG_MSG, 
                        "Error: Multiple carriers in same slot, %d, in interface slot table", 
                        i);
                
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    ADI_PARAM_ERROR_REPORT( &device->common,
                        recoveryAction,
                        i,
                        "Error: Multiple carriers in same slot in interface slot table");
                    return recoveryAction;
                }
                else
                {
                    iface_table_valid[tmp_carrier_slots[j] % slot_table_params->ifaceMaxSlots] = 1;
                }
            }
        }

        /* For enabled carriers with delay_mismatch_rel[i]  < -1/2 * threshold.... */
        if ((slot_table_params->carriersEnabled & (1 << i) &&
            (delay_mismatch_rel[i] < (int16_t)-ADRV904X_HALF_MAX_DELAY_CC)))
        {
            jesd_to_carrier_ratio = slot_table_params->carrierClkPeriod[i] / slot_table_params->jesdClkPeriod;
            for (int s = 0; s < slot_table_params->jesdMaxSlot; s++)
            {
                if ((tmp_jesd_slot_valid_calc[s] == 0) &&
                    (s < tmp_carrier_slots[i]) &&
                    (s < jesd_to_carrier_ratio))
                {
                    /* To not allow carrier to move to slot where other carriers present in interface slot table(eventhough they are invalid in cduc slot table) */
                    if (iface_table_valid[s % slot_table_params->ifaceMaxSlots] == 0)
                    {
                        invalid_slot = s;
                        invalid_slot_found = 1;
                        break;
                    }
                }
            } /* end:  s forloop */

            /* if invalid_slot_found == 1, we found a candidate first slot to move to. But we must ALSO verify all slots that follow it, at jesd_to_carrier_ratio intervals, are also "invalid" */
            if (invalid_slot_found == 1)
            {
                for (int s = slot_table_params->carrierSlots[i]; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                {
                    tmp_jesd_slot_valid_calc[s] = 0;
                }
                all_follow_slots_invalid = 1;
                for (int s = invalid_slot; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                {
                    all_follow_slots_invalid = all_follow_slots_invalid && (tmp_jesd_slot_valid_calc[s] == 0);
                }

                /* If all_follow_slots_invalid == 1 here, then first slot and all subsequent slots at the carrier ratio are available to be swapped to
                 * Else candidate slot for moving doesn't met all constraints the move
                 */
                if (all_follow_slots_invalid == 1)
                {
                    for (int s = 0; s < (slot_table_params->jesdMaxSlot / jesd_to_carrier_ratio); s = s + 1)
                    {
                        /* Swapping the slots which are occupied carrier previously & the slots which are going to be occupied by carrier */
                        tmp_jesd_slot_table[tmp_carrier_slots[i] + (s * jesd_to_carrier_ratio)] = tmp_jesd_slot_table[invalid_slot + (s * jesd_to_carrier_ratio)];
                    }
                    for (int s = invalid_slot; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                    {
                        tmp_jesd_slot_valid_calc[s] = 1;
                        tmp_jesd_slot_table[s] = i;
                    }
                    tmp_carrier_slots[i] = invalid_slot;
                }
                else
                {
                    for (int s = tmp_carrier_slots[i]; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                    {
                        tmp_jesd_slot_valid_calc[s] = 1;
                        tmp_jesd_slot_table[s] = i;
                    }
                }
            }
        } /* end of if < (-1/2 * threshold) */


        /* For enabled carriers with delay_mismatch_rel[i]  > +1/2 * threshold.... */
        if ((slot_table_params->carriersEnabled & (1 << i) &&
            (delay_mismatch_rel[i] > (int16_t)ADRV904X_HALF_MAX_DELAY_CC)))
        {
            jesd_to_carrier_ratio = slot_table_params->carrierClkPeriod[i] / slot_table_params->jesdClkPeriod;
            for (int s = 0; s < slot_table_params->jesdMaxSlot; s++)
            {
                if ((tmp_jesd_slot_valid_calc[s] == 0) &&
                    (s > tmp_carrier_slots[i]) &&
                    (s < jesd_to_carrier_ratio))
                {
                    /* To not allow carrier to move to slot where other carriers present in interface slot table(eventhough they are invalid in cduc slot table) */
                    if (iface_table_valid[s % slot_table_params->ifaceMaxSlots] == 0)
                    {
                        invalid_slot = s;
                        invalid_slot_found = 1;
                        break;
                    }
                }
            } /* end:  s forloop */

            /* if invalid_slot_found == 1, we found a candidate first slot to move to. But we must ALSO verify all slots that follow it, at jesd_to_carrier_ratio intervals, are also "invalid" */
            if (invalid_slot_found == 1)
            {
                for (int s = slot_table_params->carrierSlots[i]; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                {
                    tmp_jesd_slot_valid_calc[s] = 0;
                }
                all_follow_slots_invalid = 1;
                for (int s = invalid_slot; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                {
                    all_follow_slots_invalid = all_follow_slots_invalid && (tmp_jesd_slot_valid_calc[s] == 0);
                }

                /* This line is unique in (> 1/2) case. Not present in (< -1/2 ) case above. */
                all_follow_slots_invalid = all_follow_slots_invalid && (invalid_slot < jesd_to_carrier_ratio);

                /* If all_follow_slots_invalid == 1 here, then first slot and all subsequent slots at the carrier ratio are available to be swapped to
                 * Else candidate slot for moving doesn't met all constraints the move
                 */
                if (all_follow_slots_invalid == 1)
                {
                    for (int s = 0; s < (slot_table_params->jesdMaxSlot / jesd_to_carrier_ratio); s = s + 1)
                    {
                        /* Swapping the slots which are occupied carrier previously & the slots which are going to be occupied by carrier */
                        tmp_jesd_slot_table[tmp_carrier_slots[i] + (s * jesd_to_carrier_ratio)] = tmp_jesd_slot_table[invalid_slot + (s * jesd_to_carrier_ratio)];
                    }
                    for (int s = invalid_slot; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                    {
                        tmp_jesd_slot_valid_calc[s] = 1;
                        tmp_jesd_slot_table[s] = i;
                    }
                    tmp_carrier_slots[i] = invalid_slot;
                }
                else
                {
                    for (int s = tmp_carrier_slots[i]; s < slot_table_params->jesdMaxSlot; s = s + jesd_to_carrier_ratio)
                    {
                        tmp_jesd_slot_valid_calc[s] = 1;
                        tmp_jesd_slot_table[s] = i;
                    }
                }
            }
        } /* end of if > (+1/2 * threshold) */

    } /* end of i forloop */

    for (unsigned int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        if (slot_table_params->carriersEnabled & (1 << i))
        {
            jesd_to_carrier_ratio = slot_table_params->carrierClkPeriod[i] / slot_table_params->jesdClkPeriod;
            for (unsigned int j = tmp_carrier_slots[i]; j < slot_table_params->jesdMaxSlot; j = j + jesd_to_carrier_ratio)
            {
                tmp_jesd_slot_table[j] = i;
                tmp_jesd_slot_valid_calc[j] = 1u;
            }
        }
    }

    /* Update Slot Shuffle params with the calculated tmp vars */
    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
    {
        slot_table_params->carrierSlots[i] = tmp_carrier_slots[i];
    }
    for (int s = 0; s < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; s++)
    {
        slot_table_params->jesdSlotTable[s] = tmp_jesd_slot_table[s];
        slot_table_params->jesdSlotValid[s] = tmp_jesd_slot_valid_calc[s];
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}


static adi_adrv904x_ErrAction_e reorderSlotTable(   adi_adrv904x_Device_t* const                device,
                                                    adrv904x_SlotTableShuffleParams_t * const   slot_table_params)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    uint16_t max_carrier_slot = 0u;
    uint16_t num_of_active_slots = 0u;
    uint16_t max_carrier_slot_ratio = 0u;
    uint16_t slot_valid_arr[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    uint16_t slotTable[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, slot_table_params);

    /* Init */
    for (int i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        slotTable[i] = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        slot_valid_arr[i] = 0;
    }
    for (int i = 0; i < 8; i++)
    {
        for (int j = 0; j < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; j++)
        {
            if (slot_table_params->jesdSlotTable[j] == i)
            {
                num_of_active_slots++;
                break;
            }
        }
    }

    max_carrier_slot = 1u;
    while (max_carrier_slot < num_of_active_slots)
    {
        max_carrier_slot <<= 1;
    }

    max_carrier_slot_ratio = slot_table_params->jesdMaxSlot / max_carrier_slot;

    for (int i = 0; i < max_carrier_slot_ratio; i++)
    {
        for (int j = 0; j < max_carrier_slot; j++)
        {
            slotTable[i * max_carrier_slot + j] = slot_table_params->jesdSlotTable[(i + 1) * max_carrier_slot - 1 - j];
            slot_valid_arr[i * max_carrier_slot + j] = slot_table_params->jesdSlotValid[(i + 1) * max_carrier_slot - 1 - j];
        }
    }

    for (int i = 0; i < 64; i++)
    {
        slot_table_params->jesdSlotTable[i] = slotTable[i];
        slot_table_params->jesdSlotValid[i] = slot_valid_arr[i];
    }

    calcFirstCarrierSlot(device, slot_table_params);

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}


static adi_adrv904x_ErrAction_e updateMinDelayCducSolution( adi_adrv904x_Device_t* const                                device,
                                                            const adi_adrv904x_CarrierReconfigProfileCfgOut_t * const   pCandidate,
                                                            adi_adrv904x_CarrierReconfigProfileCfgOut_t * const         pMin)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pCandidate);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, pMin);
    
    if(pCandidate->delayCfg.delayMismatch_cc < pMin->delayCfg.delayMismatch_cc)
    {
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG,
            "Updated CDUC Minimum Solution Found. delayMismatch_cc improved %d cc --> %d cc!", 
            pMin->delayCfg.delayMismatch_cc,
            pCandidate->delayCfg.delayMismatch_cc);
#endif
        ADI_LIBRARY_MEMCPY(pMin, pCandidate, sizeof(adi_adrv904x_CarrierReconfigProfileCfgOut_t));
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}

#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)

static void printfCmodelStats(  adi_adrv904x_Device_t* const                                device,
                                const adi_adrv904x_CarrierReconfigProfileCfgOut_t * const   profile,
                                const adi_adrv904x_ChannelFilterOutputCfg_t* const          filter)
{
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG,
        "carrier\t: cfilt\t: carrier : cfilt  \t: cfilt   \t: hb tap\t: hb pipe\t: deinterleaver\t: delay match \t: resource   \t: Band align\t: Band group \t: CDUC group \t: Comb group \t: Total      \t: CDUC       ", 0);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG,
        "number \t: tap  \t: period  : tap del\t: pipe del\t: delay \t: delay  \t: delay        \t: extra delay \t: share delay\t: delay     \t: delay      \t: delay      \t: delay      \t: delay      \t: delay      ", 0);

    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; ++i)
    {
        if (profile->carriersEnabled & (1u << i))
        {
            ADI_VARIABLE_LOG(&device->common,
                ADI_HAL_LOG_MSG,
                "%5d\t: %5d\t: %5d\t  : %5d\t: %5d\t: %5d\t: %5d\t: %5d\t: %5d\t: %5d\t: %5d\t\t: %5d\t\t: %5d\t\t: %5d\t\t: %5d\t\t: %5d",
                i,
                filter->numberOfFilterTaps[i],                                  /* cfilt tap */
                (1u << profile->carrierCfgs.carrierRateRatio[i]),               /* carrier period */
                /* Items in this set are part of group delay component structure that was pushed into CDUC structure simply to print here */
                profile->delayCfg.carrierComponents[i].cfilt.tap,                 /* cfilt tap del */
                profile->delayCfg.carrierComponents[i].cfilt.pipe,                /* cfilt pip del */
                profile->delayCfg.carrierComponents[i].halfBand.tap,             /* hb tap delay */
                profile->delayCfg.carrierComponents[i].halfBand.pipe,            /* hb pipe delay */
                profile->delayCfg.carrierComponents[i].deinterleaver,             /* deinterleaver slot delay */
                profile->delayCfg.carrierComponents[i].matchEnabled,             /* delay match extra delay */
                profile->delayCfg.carrierComponents[i].gainResrc,                /* resource share delay */
                profile->delayCfg.carrierComponents[i].bandAlignDelay,          /* band align delay */
                /* Items below need to be addressed after piecewise delay calculations are finished. They put into stand-alone fields just to print */
                profile->delayCfg.groupDelayBand_cc[i],                       /* raw BandDUC group delay */
                profile->delayCfg.groupDelayCarr_cc[i],                       /* raw CDUC group delay */
                profile->delayCfg.groupDelayComb_cc[i],                       /* combined group delay (BandDUC + CDUC) in HW w/o delay buffers */
                profile->delayCfg.finalDelayTotal_cc[i],                      /* Final delay in HW:  BandDUC + CDUC + Delay Buffers in CDUC */
                profile->delayCfg.finalDelayCarr_cc[i]                        /* Final delay in HW w/o band:  CDUC + Delay Buffers in CDUC */
            );
        }
    }

    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Delay values to be inserted", 0);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Carrier number\t: Difference \t: Delay match \t: Delay match \t: Delay    ", 0);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "              \t:            \t: value       \t: enabled     \t: mismatch ", 0);

    for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; ++i)
    {
        if(profile->carrierCfgs.carrierEnable[i] > 0)
        {
            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Carrier %d\t: %10d\t: %10d\t:   %d\t\t\t:  %d",
                        (int) i,                                                                /* Carrier Number */
                        (int)profile->delayCfg.uncompOffset_cc[i],                             /* Difference between target and actual group delay before accounting for Delay Buffer Compensation */
                        (int)profile->delayCfg.compIntSamples[i],                             /* Delay match value (e.g. Buffer Delay count) */
                        (int)(profile->delayCfg.carrierComponents[i].matchEnabled != 0 ? 1 : 0), /* Delay match enabled */
                        (int)profile->delayCfg.delayDiffPerCarrier_cc[i]);                   /* Delay mismatch */
        }
    }
}


static void printfCducState(adi_adrv904x_Device_t* const                                    device, 
                              const adi_adrv904x_CarrierReconfigProfileCfgOut_t * const     profile)
{
    uint8_t bPrintSlotTablesCompact = 1U;
    uint8_t bPrintSlotTablesFull = 0U;
    uint8_t bPrintDelays = 1U;
    uint8_t bPrintSlotMatrix = 2U;

    int N_iface = profile->internalJesdCfg.ifaceMaxSlot;
    int N_carrier = profile->internalJesdCfg.maxSlot;
    int N_mod = N_carrier / N_iface;
    
    const int MAXLEN = 512;
    char msg[MAXLEN];
    int len = 0;

    /* Compact Slot Tables */
    if (bPrintSlotTablesCompact == 1U)
    {

        /* Note the valid mask */
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "    Valid Mask:       \t0x%llx", profile->internalJesdCfg.slotValid);

        /* One line with entire Carrier Slot Table */
        ADI_LIBRARY_MEMSET(&msg[0], 0, sizeof(msg));
        len = 0;
        len += ADI_LIBRARY_SNPRINTF(msg+len, MAXLEN-len, "    Carr Slots[%d]:   \t[ ", N_carrier);
        for (int i = 0; i < N_carrier; i++)
        {
            int slot_val = profile->internalJesdCfg.slotTable[i];
            if (slot_val == ADRV904X_SLOT_TABLE_UNUSED)
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "-");
            }
            else
            {
                len += ADI_LIBRARY_SNPRINTF(msg+len, MAXLEN-len, "%d", slot_val);
            }

            if (i < N_carrier - 1)
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, ", ");
            }
        }
        len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, " ]");
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "%s", msg);

        /* One line with entire Iface Slot Table */
        ADI_LIBRARY_MEMSET(&msg[0], 0, sizeof(msg));
        len = 0;
        len += ADI_LIBRARY_SNPRINTF(msg+len, MAXLEN-len, "    Iface Slots[%d]:  \t[ ", N_iface);
        for (int i = 0; i < N_iface; i++)
        {
            int slot_val = profile->internalJesdCfg.ifaceSlotTable[i];
            if (slot_val == ADRV904X_SLOT_TABLE_UNUSED)
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "-");
            }
            else
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "%d", slot_val);
            }

            if (i < N_iface - 1)
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, ", ");
            }
        }
        len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, " ]");
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "%s", msg);
    }

    /* Full Slot Tables */
    if (bPrintSlotTablesFull == 1U)
    {
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "    Iface Slot Table:", 0);
        for (int i = 0; i < N_iface; i++)
        {
            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "      s[%d]\t = %d", i, profile->internalJesdCfg.ifaceSlotTable[i]);
        }

        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Carrier Slot Table:", 0);
        for (int i = 0; i < N_carrier; i++)
        {
            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "      s[%d]\t = %d", i, profile->internalJesdCfg.slotTable[i]);
        }
    } /* end bPrintSlotTablesCompact */
    
    /* Matrix Slot Table */
    if (bPrintSlotMatrix == 1U)
    {
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "      |-----------------------------------------------------------------------------------------------------------", 0);
        /* Cslot rows (count = N_mod) */
        for (int i = 0; i < N_mod; i++)
        {
            ADI_LIBRARY_MEMSET(&msg[0], 0, sizeof(msg));
            len = 0;
            
            int carrStartIdx = i * N_iface;
            int carrEndIdx = carrStartIdx + N_iface;

            len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "      | Carr Slot[%d-%d]   \t | ", carrStartIdx, carrEndIdx - 1);
            for (int j = carrStartIdx; j < carrEndIdx; j++)
            {
                int slot_val = profile->internalJesdCfg.slotTable[j];
                if (slot_val == ADRV904X_SLOT_TABLE_UNUSED)
                {
                    len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "-- | ");
                }
                else
                {
                    len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "%2d | ", slot_val);
                }
            }
            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "%s", msg);
        }

        /* Islot row */
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "      |-----------------------------------------------------------------------------------------------------------", 0);
        ADI_LIBRARY_MEMSET(&msg[0], 0, sizeof(msg));
        len = 0;
        len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "      | Iface Slot[%d-%d]   \t | ", 0, N_iface-1);
        for (int i = 0; i < N_iface; i++)
        {
            int slot_val = profile->internalJesdCfg.ifaceSlotTable[i];
            if (slot_val == ADRV904X_SLOT_TABLE_UNUSED)
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "-- | ");
            }
            else
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "%2d | ", slot_val);
            }
        }
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "%s", msg);
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "      |-----------------------------------------------------------------------------------------------------------", 0);

    } /* end bPrintSlotMatrix */

    if (bPrintDelays == 1U)
    {
        /* One line with Delay Diff Per Carrier */
        ADI_LIBRARY_MEMSET(&msg[0], 0, sizeof(msg));
        len = 0;
        len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "Delay Diff per Carrier : [");
        for (int i = 0; i < (int)ADI_ADRV904X_MAX_CARRIERS; i++)
        {
            len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "%d", profile->delayCfg.delayDiffPerCarrier_cc[i]);
            if (i < (int)ADI_ADRV904X_MAX_CARRIERS - 1)
            {
                len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, ", ");
            }
        }
        len += ADI_LIBRARY_SNPRINTF(msg + len, MAXLEN - len, "] cc");
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "%s", msg);

        /* Total Carrier Delay Mismatch */
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "    Carrier Delay Mismatch = %d cc", profile->delayCfg.delayMismatch_cc);
    }

}
#endif


static void adiLfsrSeedSet(adi_adrv904x_Device_t* const device, uint16_t seed)
{
    device->devStateInfo.carrierLfsrValue = seed;
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "ADI LFSR seeded with seed = 0x%x", seed);
}


static uint16_t adiLfsrShift(adi_adrv904x_Device_t* const device)
{
    /* Get current lfsr value from device handle */
    uint16_t lfsr = device->devStateInfo.carrierLfsrValue;
    
    uint16_t prbs = ((lfsr >> 0) ^ (lfsr >> 3) ^ (lfsr >> 5) ^ (lfsr >> 7)) & 1u;
    uint16_t new_lfsr = (lfsr >> 1) | (prbs << 15);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "ADI LFSR change: 0x%x --> 0x%x ", lfsr, new_lfsr);
    
    /* Store result back in device handle */
    device->devStateInfo.carrierLfsrValue = new_lfsr;

    return (new_lfsr);
}


static int adiRandInt(adi_adrv904x_Device_t* const device)
{
    uint16_t tmp = adiLfsrShift(device);
    int ret = (int)tmp;
    return (ret);
}

/* function: randomSlotGet() -- port of cmodel function "printRandoms"
 * inputs:
 *      - lower: lowest allowed slot based on carrier ratio
 *      - upper: highest allowed slot based on carrier ratio
 * outputs:
 *      - none
 * return:
 *      - random slot selected
 */

static int randomSlotGet(adi_adrv904x_Device_t* const device, int lower, int upper)
{
    int num = (adiRandInt(device) % (upper - lower + 1)) + lower;
    return num;
}


/* function: randomTableGenCmodel() -- port of cmodel function "random_table_gen"
 * inputs:
 *      - carr_enable[ADI_ADRV904X_MAX_TXCHANNELS]
 *      - carr_clk_period[ADI_ADRV904X_MAX_TXCHANNELS]
 *      - jesdClkPeriod
 *      - jesdMaxSlot
 *      - ifaceMaxSlots
 * outputs:
 *      - carr_deinterleaver_slot[ADI_ADRV904X_MAX_TXCHANNELS]
 *      - jesdSlotTable[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS]
 *      - jesd_slot_valid_calc[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS]
 *      - error_struct
 * return:
 *      - int (nonzero return indicates an error occurred)
 */

static adi_adrv904x_ErrAction_e randomTableGenCmodel( adi_adrv904x_Device_t* const device,
    const int carr_enable[ADI_ADRV904X_MAX_TXCHANNELS], const int carr_clk_period[ADI_ADRV904X_MAX_TXCHANNELS], const int jesdClkPeriod, const int jesdMaxSlot, const int ifaceMaxSlots,
    int carr_deinterleaver_slot[ADI_ADRV904X_MAX_TXCHANNELS], int jesdSlotTable[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS], int jesd_slot_valid_calc[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS])
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    int log2_jesd_max_slot = 0;
    int array_size = 0;
    int log2_carr_rate = 0;
    int index = 0;
    int array_size_per_rate[ADRV904X_RAND_TABLE_NUM_ARRAY_SIZES] = { 1, 2, 4, 8, 16, 32, 64 };

    int jesd_to_carr_ratio[ADI_ADRV904X_MAX_TXCHANNELS];
    int carr_rand[ADI_ADRV904X_MAX_TXCHANNELS];
    int slot_found[ADI_ADRV904X_MAX_TXCHANNELS];
    int iface_table_valid[ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS];
    int slot_array[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    int slot_array_copy[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    int array_size_per_rate_copy[ADRV904X_RAND_TABLE_NUM_ARRAY_SIZES];

    /* Initialize Outputs and lcl vars */
    for (int c = 0; c < (int)ADI_ADRV904X_MAX_TXCHANNELS; c++)
    {
        jesd_to_carr_ratio[c] = carr_clk_period[c] / jesdClkPeriod;
        carr_rand[c] = 0;
        slot_found[c] = 0;
        carr_deinterleaver_slot[c] = 0;
    }
    for (int c = 0; c < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; c++)
    {
        jesdSlotTable[c] = ADRV904X_SLOT_TABLE_UNUSED;
        jesd_slot_valid_calc[c] = 0;
        slot_array[c] = c;
        slot_array_copy[c] = 0;
    }

    /* Initialize lcl vars */
    for (int v = 0; v < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; v++)
    {
        iface_table_valid[v] = 0;
    }

    for (int j = 0; j < ADRV904X_RAND_TABLE_NUM_ARRAY_SIZES; j++)
    {
        array_size_per_rate_copy[j] = 0u;
    }

    log2_jesd_max_slot = log2(jesdMaxSlot);

    /* Get random starting slots for each carrier */
    for (int c = 0; c < (int)ADI_ADRV904X_MAX_TXCHANNELS; c++)
    {
        slot_found[c] = 0;
        if (carr_enable[c])
        {
            for (int s = 0; s < jesdMaxSlot; s++)
            {
                slot_array_copy[s] = slot_array[s];
            }
            for (int j = 0; j < ADRV904X_RAND_TABLE_NUM_ARRAY_SIZES; j++)
            {
                array_size_per_rate_copy[j] = array_size_per_rate[j];
            }
            log2_carr_rate = log2(jesd_to_carr_ratio[c]);
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "log2_carr_rate %d = %d", c, log2_carr_rate);
#endif
            for (int i = 0; i < jesd_to_carr_ratio[c]; i++)
            {
                if (i == 0)
                {
                    array_size = array_size_per_rate[log2_carr_rate];
                    index = randomSlotGet(device, 0, array_size - 1);
                    carr_rand[c] = slot_array[index];
                }
                else
                {
                    array_size = array_size_per_rate_copy[log2_carr_rate];
                    index = randomSlotGet(device, 0, array_size - 1);
                    carr_rand[c] = slot_array_copy[index];
                }
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "slot picked for carr %d = %d", c, carr_rand[c]);
#endif
                if (iface_table_valid[carr_rand[c] % ifaceMaxSlots] == 0)
                {
                    slot_found[c] = 1;
                }
                for (int s = carr_rand[c]; s < jesdMaxSlot; s = s + jesd_to_carr_ratio[c])
                {
                    slot_found[c] = slot_found[c] && (jesd_slot_valid_calc[s] == 0);
                }
                if (slot_found[c] == 1)
                {
                    iface_table_valid[carr_rand[c] % ifaceMaxSlots] = 1;
                    for (int s = 0; s < jesdMaxSlot; s = s + 1)
                    {
                        if (((slot_array[s] - carr_rand[c]) % jesd_to_carr_ratio[c]) == 0)
                        {
                            for (int k = s; k < jesdMaxSlot; k++)
                            {
                                slot_array[k] = slot_array[k + 1];
                            }
                        }
                    }
                    for (int s = log2_carr_rate; s <= log2_jesd_max_slot; s++)
                    {
                    }
                    break;
                }
                else
                {
                    for (int s = index; s < jesdMaxSlot; s = s + 1)
                    {
                        if (((slot_array_copy[s] - carr_rand[c]) % jesd_to_carr_ratio[c]) == 0)
                        {
                            for (int k = s; k < jesdMaxSlot; k++)
                            {
                                slot_array_copy[k] = slot_array_copy[k + 1];
                            }
                        }
                    }
                    for (int s = log2_carr_rate; s <= log2_jesd_max_slot; s++)
                    {
                        array_size_per_rate_copy[s] = array_size_per_rate_copy[s] - (1 << (s - log2_carr_rate));
                    }
                }
            }
            if (slot_found[c] == 0)
            {
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "ERROR: Unable to find slot for carrier %d in random table gen", c);
#endif
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                return (recoveryAction);
            }
            else
            {
                for (int s = carr_rand[c]; s < jesdMaxSlot; s = s + jesd_to_carr_ratio[c])
                {
                    jesdSlotTable[s] = c;
                    jesd_slot_valid_calc[s] = 1;
                }
                carr_deinterleaver_slot[c] = carr_rand[c];
                recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
            }
        }
    }
    
    return recoveryAction;
}

/* function: randomTableGenWrapper() -- not a port of a particular function, but calls randomTableGenCmodel() with the necessary glue logic around it
 * Notes:
 *      - Convert configurator input data into required args for randomTableGenCmodel(), which should match actual cmodel
 *      - Call randomTableGenCmodel()
 *          - NOTE: cmodel function expects "Carrier_enabled" array for 8 carriers. This fails to find dummy carriers and handle them appropriately
 *                  Replace simple :carrier enabled" with concept of "carrier used", which can be determined by checking carrier sample_rate
 *      - Convert outputs args from randomTableGenCmodel() into output data required for configurator
 * inputs:
 *      - cduc
 * in/out:
 *      - jesd_prm
 *      - error_struct
 * return:
 *      - void
 */

static adi_adrv904x_ErrAction_e randomTableGenWrapper(  adi_adrv904x_Device_t* const                device,
                                                        const adi_adrv904x_CarrierRadioCfg_t* const cduc,
                                                        adrv904x_CarrierJesdParameters_t* const     jesd_prm)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    unsigned int hsdig_rate_in_kHz = 0;

    /* ------------------------------------------------------------------------------------------------- */
    /* Glue logic to convert input args into into args required by randomTableGenCmodel */
    int jesdClkPeriod = 1 << jesd_prm->divide;
    int jesdMaxSlot = jesd_prm->maxSlot;
    int ifaceMaxSlots = jesd_prm->ifaceMaxSlot;
    int carr_enable[ADI_ADRV904X_MAX_TXCHANNELS];
    int carr_clk_period[ADI_ADRV904X_MAX_TXCHANNELS];
    int dummy_iface_slot_count[ADI_ADRV904X_MAX_TXCHANNELS];


    /* Extract required info from cduc */
    hsdig_rate_in_kHz = (1 << jesd_prm->divide) * jesd_prm->frequency_kHz;
    for (int c = 0; c < (int)ADI_ADRV904X_MAX_TXCHANNELS; c++)
    {
        /* Extract "carr_enable" info from cduc. This will EXCLUDE dummy carriers from rand table generation */
        carr_enable[c] = cduc->carriers[c].enable;

        if (carr_enable[c] == 0)
        {
            carr_clk_period[c] = 0;
        }
        else
        {
            carr_clk_period[c] = hsdig_rate_in_kHz / cduc->carriers[c].sampleRate_kHz;
        }

        /* Count the number of slots taken by any Dummy carrier. They will need to be added back in manually after random table generation
         * keep count/carrier
         */
        dummy_iface_slot_count[c] = 0;
        if ((cduc->carriers[c].enable == 0) &&
            (cduc->carriers[c].sampleRate_kHz > 0u))
        {
            for (int s = 0; s < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; s++)
            {
                if (jesd_prm->ifaceSlotTable[s] == c)
                {
                    dummy_iface_slot_count[c]++;
                }
            }
        }
    }

    /* Uninitialized "output" vars to be returned */
    int carr_deinterleaver_slot[ADI_ADRV904X_MAX_TXCHANNELS];
    int jesdSlotTable[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    int jesd_slot_valid_calc[ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS];
    
    /* ------------------------------------------------------------------------------------------------- */

    /* Call main port of cmodel function
     * NOTE again: carr_used passed in. NOT simple carr_enable
     */
    recoveryAction = randomTableGenCmodel(
        device,
        carr_enable, carr_clk_period, jesdClkPeriod, jesdMaxSlot, ifaceMaxSlots,  /* inputs */
        carr_deinterleaver_slot, jesdSlotTable, jesd_slot_valid_calc);   /* outputs */
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        return recoveryAction;
    }

    /* ------------------------------------------------------------------------------------------------- */
    /* Glue logic to convert cmodel output results into jesd_prm structure required by configurator */

    /* Overwrite or calculate fields in jesd_prm with the results where they were affected. 
     * NOTE: THIS IS KEY. jesd_prm is always used to reset a slot tables throughout shuffling
     * output "carr_deinterleaver_slot" unused for now
     */
    (void)carr_deinterleaver_slot;

    jesd_prm->slotValid = 0u;                                                      /* Re-Initialize 64bit slotValid word to 0 until filled later */
    for (int s = 0; s < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; s++)
    {
        jesd_prm->slotValid |= ((1ull & jesd_slot_valid_calc[s]) << s);            /* bitwise-OR this carrier-slot's valid bit into 64bit word */
        jesd_prm->slotTable[s] = jesdSlotTable[s];                               /* direct-copy of carrier-slot table */
    }

    for (int i = 0; i < jesd_prm->ifaceMaxSlot; i++)
    {
        jesd_prm->ifaceSlotTable[i] = ADRV904X_SLOT_TABLE_UNUSED;                 /* Re-Initialize all Iface slots as UNUSED until filled later */

        unsigned short tmp = ADRV904X_SLOT_TABLE_UNUSED;
        for (int c = i; c < jesd_prm->numSlots; c = c + jesd_prm->ifaceMaxSlot)
        {
            unsigned short cval = jesd_prm->slotTable[c];
            if (cval != ADRV904X_SLOT_TABLE_UNUSED)
            {
                if (tmp == ADRV904X_SLOT_TABLE_UNUSED)                              /* carrier-slot has a carrier ID to map to iface-slot */
                {
                    tmp = cval;                                                     /* tmp iface-slot result is still UNUSED  --> overwrite with cval */
                }
                else if (tmp != cval)                                               /* tmp iface-slot result is not UNUSED  --> verify it matches cval */
                {
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG,
                        "ERROR: JESD_PRM IFACE SLOT TABLE element %d cannot be allocated for more than one carrier slot. Check carriers %d and %d in random table generation",
                        i,
                        tmp,
                        cval);
#endif
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    return (recoveryAction);
                }
            }
        }

        jesd_prm->ifaceSlotTable[i] = tmp;                                        /* Set Iface slot to final tmp value */

    } /* end of iface-slot forloop */

    /* Place dummy carriers into the Iface slot table, in the first empty slots found */
    for (int c = 0; c < (int)ADI_ADRV904X_MAX_TXCHANNELS; c++)
    {
        /* Check if We have dummy carrier (i.e. carrier sample rate > 0 and carrier is not enabled) */
        if ((cduc->carriers[c].enable == 0) &&
            (cduc->carriers[c].sampleRate_kHz > 0u))
        {
            /* iface table: insert carrier  into first UNUSED slots found until all removed slots have been reinserted */
            int s = 0;
            while (
                (dummy_iface_slot_count[c] > 0) &&
                (s < jesd_prm->ifaceMaxSlot))
            {
                if (jesd_prm->ifaceSlotTable[s] == ADRV904X_SLOT_TABLE_UNUSED)
                {
                    jesd_prm->ifaceSlotTable[s] = c;
                    dummy_iface_slot_count[c]--;
                }

                s++;
            }

            /* Check if we ran out of empty iface slots before all dummies could be reinserted */
            if (dummy_iface_slot_count[c] != 0)
            {
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "ERROR: Ran out of space to reinsert dummy carriers", 0);
#endif
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                return (recoveryAction);
            }
        }
    }

    /* ------------------------------------------------------------------------------------------------- */

    return recoveryAction;
}


/**
* \brief Performs cduc carrier delay calculations
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] selectedChannel a channel used to read the carrier registers. Any channel that's enabled in this config will work.
* \param[in] carrierConfigsOut holds the calculated values during reconfiguration
* \param[in, out] prms delay configuration written to part
*
* \retval adi_adrv904x_ErrAction_e - ADI_ADRV904X_ERR_ACT_NONE if Successful
*/

static adi_adrv904x_ErrAction_e adrv904x_CalculateCducDelayMatch(   adi_adrv904x_Device_t* const                                device,
                                                                    const uint32_t                                              selectedChannel,
                                                                    const adi_adrv904x_CarrierRadioCfg_t* const                 carrierConfigsIn,
                                                                    const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    carrierConfigsOut,
                                                                    const adi_adrv904x_ChannelFilterOutputCfg_t* const          carrierChannelFilter,
                                                                    adi_adrv904x_CarrierDelayParameters_t* const                prms)
{
    const int num_carr = (int)ADI_ADRV904X_MAX_CARRIERS;
    const int NUM_DELAY_ESTIMATE_LOOPS = 3;
    const uint64_t hsdigclk_limit = 1000000u; /* 1 GHz max rate for hsdig clk */
    
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsIn);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierChannelFilter);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);
    
    /* helper variables */
    uint8_t i = 0;
    adrv904x_CarrierResourceSharePrm_t resrc_prm;
    ADI_LIBRARY_MEMSET(&resrc_prm, 0, sizeof(resrc_prm));
    resrc_prm.numCarriers = num_carr;
    
    /* input variable declarations */
    /* 4 for jesd_clk=245.76, 2 for jesd_clk=491.52 and so on */
    uint32_t jesdClkPeriod = (1u << carrierConfigsOut->internalJesdCfg.divide);
    
    
    uint8_t carr_num_hb[num_carr];
    ADI_LIBRARY_MEMSET(&carr_num_hb, 0, sizeof(carr_num_hb));
    
    uint8_t carr_deinterleaver_slot[num_carr];
    ADI_LIBRARY_MEMSET(&carr_deinterleaver_slot, 0, sizeof(carr_deinterleaver_slot));
    
    uint32_t band_clk_period[ADI_ADRV904X_NO_OF_BANDS];
    band_clk_period[0] = (1 << device->initExtract.tx.txChannelCfg[selectedChannel].bandRatio[0]);
    band_clk_period[1] = (1 << device->initExtract.tx.txChannelCfg[selectedChannel].bandRatio[1]);
    
    uint16_t band_latencies_cc[ADI_ADRV904X_NO_OF_BANDS];
    band_latencies_cc[0] = device->initExtract.txBandLatency[selectedChannel].duc_cc[0];
    band_latencies_cc[1] = device->initExtract.txBandLatency[selectedChannel].duc_cc[1];
    int32_t band_en_offset[ADI_ADRV904X_NO_OF_BANDS];
    ADI_LIBRARY_MEMSET(&band_en_offset, 0, sizeof(band_en_offset));

    /* derived variable declarations */
    uint32_t hb_resource_share_delay_pipe = 2u;
    uint32_t hb_transpose_pipe = 1u;
    uint32_t hb_additional_pipe_delay = hb_resource_share_delay_pipe + hb_transpose_pipe;

    uint32_t nco_resource_share_delay_pipe = 2u;
    uint32_t dds_cmul_delay = 8u;
    uint32_t gain_mul_delay = jesdClkPeriod;
    uint32_t pre_band_align_pipe_delay = 1u;
    uint16_t additional_pipe_delay = dds_cmul_delay + gain_mul_delay + pre_band_align_pipe_delay;
    uint32_t band_align_pipe_delay = 1u;

    uint32_t tx_sample_clk_period = 2u;                     /* FT clk in digital core & PDS */
    uint32_t band_en_cntr_val_jesd_sync = 1u;               /* Counter value of band_en gen logic when first sync generated */
    uint32_t pipe_on_sync_jesd = 3u * jesdClkPeriod;      /* 3 pipes inside JESD */
    uint32_t ft_pipe_on_sync = 3u * tx_sample_clk_period;   /* 3 FT pipes in DC(2) & PDS(1) */
    uint32_t ft_del_on_sync = (jesdClkPeriod > ft_pipe_on_sync) ? 0u : (ft_pipe_on_sync / jesdClkPeriod) * jesdClkPeriod;

    uint32_t deint_pipe = 3 * jesdClkPeriod;
    
    uint32_t summer_pipe[num_carr];
    ADI_LIBRARY_MEMSET(&summer_pipe, 0, sizeof(summer_pipe));
    
    uint32_t pre_bypass_pipe[ADI_ADRV904X_NO_OF_BANDS];
    ADI_LIBRARY_MEMSET(&pre_bypass_pipe, 0, sizeof(pre_bypass_pipe));
    uint8_t change_in_delay_enables = 0u;
    uint32_t pre_stage_carr_en = 0u;
    uint32_t mask = 0u;
    uint32_t max_carr_delay = 0u;
    uint16_t tap_number = 0u;

    /* Initialize delay prms structure*/
    ADI_LIBRARY_MEMSET(prms, 0, sizeof(adi_adrv904x_CarrierDelayParameters_t));
    prms->noOfCarriers = num_carr;
    prms->jesdFrequency_kHz = carrierConfigsOut->internalJesdCfg.frequencyKhz;
    uint16_t cduc_clk_div = 0u; /* fixed div-by-1 */
    prms->clkToJesdRatioLog2 = (carrierConfigsOut->internalJesdCfg.divide - cduc_clk_div);

    /* Populate local input variable declarations with solved values */
    for (i = 0u; i < num_carr; i++)
    {
        resrc_prm.clkPeriod[i] = 1u;
        resrc_prm.dlyPrev[i] = 0u;

        summer_pipe[i] = band_clk_period[carrierConfigsOut->carrierCfgs.bandSelect[i]];
        carr_num_hb[i] = (uint8_t)carrierConfigsOut->carrierCfgs.interpolationRatio[i];
        carr_deinterleaver_slot[i] = 0u;
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            for (uint8_t s = 0u; s < ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; s++)
            {
                if (carrierConfigsOut->internalJesdCfg.slotTable[s] == i)
                {
                    carr_deinterleaver_slot[i] = s;
                    break;
                }
            }
        }
    }

    /* Pre bypass pipe on power meas clk which is 2 cduc cyles. But the flops after that in TX & flop before it in CDUC, Both are on Band clk. 
     * If the flop structure is like "flop on lower freq clk -> flop on high freq clk -> flop on low freq clk", then we can ignore flop on high freq clk
     */
    for (i = 0u; i < ADI_ADRV904X_NO_OF_BANDS; i++)
    {
        pre_bypass_pipe[i] = (band_clk_period[i] > 2) ? 0 : 2;
    }

    /* -------------------------------------------------------------
     * calculating delays
     * ------------------------------------------------------------- */
    
    /* starting delay */
    for (i = 0u; i < num_carr; i++)
    {
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            prms->carrSamplePeriod_cc[i] = (1u << carrierConfigsOut->carrierCfgs.carrierRateRatio[i]);
            prms->carrierComponents[i].cfilt.pipe = cfiltPipeDelay((uint8_t)carrierChannelFilter->bypassFilter[i], jesdClkPeriod, carrierChannelFilter->dataPipeStop[i], prms->carrSamplePeriod_cc[i]);
            prms->carrierComponents[i].deinterleaver = interleaverDelay(carr_deinterleaver_slot[i], jesdClkPeriod);
        }
    }

    /* First pass of the loop is to determine which carriers will use delay matching.
     * Second pass of the loop is to calculate each carrier delay with the delay matching component included.
     * Third pass of the loop is to turn off delay matching for carriers that resolved to matching = on but num buffers = 0 in 2nd loop
     */
    for (int k = 0; k < NUM_DELAY_ESTIMATE_LOOPS; k++)
    {
        /* initialize parameters altered by the loop operation */
        for (i = 0u; i < num_carr; i++)
        {
            resrc_prm.clkPeriod[i] = prms->carrSamplePeriod_cc[i];
            prms->carrierComponents[i].halfBand.pipe = 0u;
        }
        /* Half band pipe delay calculations */
        for (uint8_t hb = 0u; hb < ADRV904X_NO_OF_HALF_BAND_DELAYS; hb++)
        {
            pre_stage_carr_en = 0u;
            for (i = 0; i < num_carr; i++)
            {
                resrc_prm.dlyPrev[i] = 
                    prms->carrierComponents[i].deinterleaver +
                    prms->carrierComponents[i].cfilt.pipe +
                    prms->carrierComponents[i].matchEnabled +
                    prms->carrierComponents[i].halfBand.pipe;
                if (carr_num_hb[i] > hb)
                {
                    resrc_prm.clkPeriod[i] >>= 1u;
                }
                pre_stage_carr_en |= (carr_num_hb[i] > hb) ? (carrierConfigsOut->carriersEnabled & (1u << i)) : 0u;
            }
            for (i = 0; i < num_carr; i++)
            {
                if (carr_num_hb[i] > hb)
                {
                    mask = (hb == 0) ? 0xFFu : (i < (ADI_ADRV904X_MAX_CARRIERS >> 1u)) ? 0x0Fu : 0xF0u;
                    prms->carrierComponents[i].halfBand.pipe += resourceShareDelay(device, &resrc_prm, (pre_stage_carr_en & mask), 1u, i) + hb_additional_pipe_delay;
                }
            }
        }

        /* Accounting for resource share block used before NCO
         * Note: This final sum is done because the hb loop above recalcs delays at start of loop, but if last half band is used then it's extra delay will be missing
         * Need to run the sum one more time just in case last hb was used and contributed
         */
        for (i = 0u; i < num_carr; i++) {
            if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
            {
                resrc_prm.dlyPrev[i]= 
                    prms->carrierComponents[i].deinterleaver +
                    prms->carrierComponents[i].cfilt.pipe +
                    prms->carrierComponents[i].matchEnabled +
                    prms->carrierComponents[i].halfBand.pipe;
            }
        }
        for (i = 0u; i < num_carr; i++)
        {
            mask = (i < (ADI_ADRV904X_MAX_CARRIERS >> 1u)) ? 0x0Fu : 0xF0u;
            prms->carrierComponents[i].gainResrc = resourceShareDelay(device, &resrc_prm, (carrierConfigsOut->carriersEnabled & mask), 1u, i) + nco_resource_share_delay_pipe;
        }

        /* Band offset delays */
        for (int b = 0; b < (int)ADI_ADRV904X_NO_OF_BANDS; b++)
        {
            for (int j = 0; j < 10; j++)
            {
                band_en_offset[b] = (band_clk_period[b] - 1) - (j * jesdClkPeriod);
                if (band_en_offset[b] < 0)
                {
                    band_en_offset[b] = (band_clk_period[b] - 1) - ((j - 1) * jesdClkPeriod);
                    break;
                }
            }
        }

        /* hb filters, channel filter, interleaver delays */
        max_carr_delay = 0u;
        for (i = 0u; i < num_carr; i++) {
            if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
            {
                if (carrierChannelFilter->bypassFilter[i] == 0u)
                {
                    /* use zero padded channel filter tap count here */
                    tap_number = carrierChannelFilter->oddFilterTaps[i] ? carrierChannelFilter->numberOfFilterTaps[i] - 1u : carrierChannelFilter->numberOfFilterTaps[i];
                    prms->carrierComponents[i].cfilt.tap = filterDelay(tap_number, prms->carrSamplePeriod_cc[i]);
                }
                prms->carrierComponents[i].halfBand.tap = hbFilterDelay(carr_num_hb[i], prms->carrSamplePeriod_cc[i]);

                prms->groupDelayCarr_cc[i] =
                    prms->carrierComponents[i].cfilt.tap +
                    prms->carrierComponents[i].cfilt.pipe +
                    prms->carrierComponents[i].halfBand.tap +
                    prms->carrierComponents[i].halfBand.pipe +
                    prms->carrierComponents[i].deinterleaver +
                    prms->carrierComponents[i].matchEnabled +
                    prms->carrierComponents[i].gainResrc +
                    deint_pipe +
                    additional_pipe_delay;
                
                int tmp_band_select = carrierConfigsOut->carrierCfgs.bandSelect[i];
                if (((prms->groupDelayCarr_cc[i] + band_en_cntr_val_jesd_sync + pipe_on_sync_jesd + ft_del_on_sync) % band_clk_period[tmp_band_select]) == 0)
                {
                    prms->carrierComponents[i].bandAlignDelay = 0;
                }
                else
                {
                    prms->carrierComponents[i].bandAlignDelay = 
                        band_clk_period[tmp_band_select] - 
                        ((prms->groupDelayCarr_cc[i] + band_en_cntr_val_jesd_sync + pipe_on_sync_jesd + ft_del_on_sync) % band_clk_period[tmp_band_select]);
                }
                /* Final sum of carrier group delay (CDUC alone) */
                prms->groupDelayCarr_cc[i] =
                    prms->groupDelayCarr_cc[i] +
                    prms->carrierComponents[i].bandAlignDelay +
                    band_align_pipe_delay +
                    summer_pipe[i] +
                    pre_bypass_pipe[tmp_band_select];
                
                /* Sum of (BandDUC + CDUC) to get combined group delay, which determines starting points when matching/minimizing skew between carriers */
                prms->groupDelayBand_cc[i] = band_latencies_cc[tmp_band_select];
                prms->groupDelayComb_cc[i] =
                    prms->groupDelayBand_cc[i] +
                    prms->groupDelayCarr_cc[i];
                 

                /* Track max( prms->groupDelayComb_cc[i] ) */
                max_carr_delay = (max_carr_delay > prms->groupDelayComb_cc[i]) ? max_carr_delay : prms->groupDelayComb_cc[i];
            }
            else
            {
                /* Zero out group delay results for disabled carriers */
                prms->groupDelayBand_cc[i] = 0u;
                prms->groupDelayCarr_cc[i] = 0u;
                prms->groupDelayComb_cc[i] = 0u;
            }
        }

        /* Calculate hsdigclk from sample rate */
        uint64_t hsdigclk_calc_kHz = 0;
        uint64_t max_hsdigclk_kHz = 0;
        for (int cc = 0; cc < prms->noOfCarriers; cc++)
        {
            
            for (int n = 0; hsdigclk_calc_kHz < hsdigclk_limit; ++n)
            {
                hsdigclk_calc_kHz = carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[cc] * (1 << n);
                max_hsdigclk_kHz = hsdigclk_calc_kHz < hsdigclk_limit ? hsdigclk_calc_kHz : max_hsdigclk_kHz;
            }
        }

        /* Set target delays
         *      - if user-provided custom delay value == 0, use target[i] = max_carr_delay of all enabled carriers found above
         *      - if user-provided custom delay value != 0, use target[i] = custom[i] as long as custom[i] >= groupDelayComb_cc[i]
         */
        for (i = 0u; i < num_carr; i++)
        {
            if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
            {
                uint64_t tmp_lat = carrierConfigsIn->carriers[i].absLatencyOverride_ns;
                tmp_lat *= max_hsdigclk_kHz;
                tmp_lat <<= 1u;
                tmp_lat /= 1000000;
                tmp_lat += 1u;
                tmp_lat >>= 1u;
                
                uint16_t custom_target_cc = (uint16_t)(tmp_lat);

                if (custom_target_cc == 0)
                {
                    prms->targetDelay_cc[i] = max_carr_delay;
                }
                else if (custom_target_cc < prms->groupDelayComb_cc[i])
                {
                    /* Check Latency Override is Possible */
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                    ADI_VARIABLE_LOG(&device->common,
                        ADI_HAL_LOG_MSG,
                        "Latency Override %d ns --> %d cc for Carrier %d has to be larger than Calculated Group Delay Value %d cc",
                        carrierConfigsIn->carriers[i].absLatencyOverride_ns,
                        custom_target_cc,
                        i,
                        prms->groupDelayComb_cc[i]);
#endif
                    recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, "Latency Override provided for a carrier must be larger than default latency calculation");
                    return recoveryAction;
                }
                else
                {
                    prms->targetDelay_cc[i] = custom_target_cc;
                }

                /* Calculate uncompensated offset b/w this carrier's actual group delay vs. target delay */
                prms->uncompOffset_cc[i] = prms->targetDelay_cc[i] - prms->groupDelayComb_cc[i];
            }
        }

        /* Assume that there are not changes in 'matchEnabled' delays numbers until we find otherwise */
        change_in_delay_enables = 0u;

        /* If there have been no changes for ANY carrier delay matchEnabled value, no need to recalculate delays */
        if (change_in_delay_enables == 0u)
        {
            break;
        }
    }
    
    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return (recoveryAction);
}

/**
* \brief Performs cddc carrier delay calculations
*
* \dep_begin
* \dep{device->common.devHalInfo}
* \dep_end
*
* \param[in] device Pointer to the ADRV904X device data structure
* \param[in] selectedChannel The channel used to configure, any channel enabled in this profile will work
* \param[in] carrierConfigsOut holds the calculated values during reconfiguration
* \param[in] carrierChannelFilter holds output settings from FW channel filter calculation
* \param[in, out] prms delay configuration written to part
*
* \retval adi_adrv904x_ErrAction_e - ADI_ADRV904X_ERR_ACT_NONE if Successful
*/

static adi_adrv904x_ErrAction_e adrv904x_CalculateCddcDelayMatch(   adi_adrv904x_Device_t* const                                device,
                                                                    const uint32_t                                              selectedChannel,
                                                                    const adi_adrv904x_CarrierRadioCfg_t* const                 carrierConfigsIn,
                                                                    const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    carrierConfigsOut,
                                                                    const adi_adrv904x_ChannelFilterOutputCfg_t* const          carrierChannelFilter,
                                                                    adi_adrv904x_CarrierDelayParameters_t* const                prms)
{
    const int num_carr = (int)ADI_ADRV904X_MAX_CARRIERS;
    const uint64_t hsdigclk_limit = 1000000u; /* 1 GHz max rate for hsdig clk */
    
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsIn);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierChannelFilter);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, prms);
    
    /* helper variables */
    uint8_t i = 0;
    adrv904x_CarrierResourceSharePrm_t resrc_prm;
    ADI_LIBRARY_MEMSET(&resrc_prm, 0, sizeof(resrc_prm));
    resrc_prm.numCarriers = num_carr;
    
    /* input variable declarations */
    /* 4 for jesd_clk=245.76, 2 for jesd_clk=491.52 and so on */
    uint32_t jesdClkPeriod = (1u << carrierConfigsOut->internalJesdCfg.divide);
    
    uint8_t carr_num_hb[num_carr];
    ADI_LIBRARY_MEMSET(&carr_num_hb, 0, sizeof(carr_num_hb));
    
    uint32_t carr_interleaver_slot[num_carr];
    ADI_LIBRARY_MEMSET(&carr_interleaver_slot, 0, sizeof(carr_interleaver_slot));
    
    uint32_t band_clk_period[ADI_ADRV904X_NO_OF_BANDS];
    band_clk_period[0] = (1 << device->initExtract.rx.rxChannelCfg[selectedChannel].bandRatio[0]);
    band_clk_period[1] = (1 << device->initExtract.rx.rxChannelCfg[selectedChannel].bandRatio[1]);
    
    uint16_t band_latencies_cc[ADI_ADRV904X_NO_OF_BANDS];
    band_latencies_cc[0] = device->initExtract.rxBandLatency[selectedChannel].ddc_cc[0];
    band_latencies_cc[1] = device->initExtract.rxBandLatency[selectedChannel].ddc_cc[1];
    /* derived variable declarations */
    uint32_t dds_cmul_delay = 8u;
    uint16_t tap_number = 0u;
    uint32_t hb_resource_share_delay_pipe = 2u;
    uint32_t hb_transpose_pipe = 1u;
    uint32_t hb_additional_pipe_delay = hb_resource_share_delay_pipe + hb_transpose_pipe;
    
    uint32_t pre_stage_carr_en = 0u;
    uint32_t mask = 0u;

    /* Initialize delay prms structure */
    ADI_LIBRARY_MEMSET(prms, 0, sizeof(adi_adrv904x_CarrierDelayParameters_t));
    prms->noOfCarriers = num_carr;
    prms->jesdFrequency_kHz = carrierConfigsOut->internalJesdCfg.frequencyKhz;
    uint16_t cduc_clk_div = 0u; /* fixed div-by-1 */
    prms->clkToJesdRatioLog2 = (carrierConfigsOut->internalJesdCfg.divide - cduc_clk_div);

    /* Populate local input variable declarations with solved values */
    for (i = 0u; i < num_carr; i++)
    {
        resrc_prm.clkPeriod[i] = 1u;
        resrc_prm.dlyPrev[i] = 0u;

        carr_num_hb[i] = (uint8_t)carrierConfigsOut->carrierCfgs.interpolationRatio[i];
        carr_interleaver_slot[i] = 0u;

        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            for (uint8_t s = 0u; s < ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; s++)
            {
                if (carrierConfigsOut->internalJesdCfg.slotTable[s] == i)
                {
                    carr_interleaver_slot[i] = s;
                    break;
                }
            }
        }
    }
    
    /* -------------------------------------------------------------
     * calculating delays
     * ------------------------------------------------------------- */
    
    /* starting delay */
    for (i = 0u; i < num_carr; i++)
    {   
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            prms->carrSamplePeriod_cc[i] = (1u << carrierConfigsOut->carrierCfgs.carrierRateRatio[i]);
        }
        /* Assuming cddc_clk_period is 1 sample
         * powermeas_period is 2 samples (clock rate is 491.52Mhz)
         */
        int tmp_band_select = carrierConfigsOut->carrierCfgs.bandSelect[i];
        prms->carrierComponents[i].halfBand.pipe = cddcHbSlotGenDelay(i, 1u, band_clk_period[tmp_band_select], 2u) + dds_cmul_delay;
    }

    /* Half band pipe delay calculations */
    for (uint8_t hb = ADRV904X_NO_OF_HALF_BAND_DELAYS; hb > 0; hb--)
    {
        pre_stage_carr_en = 0u;
        for (i = 0u; i < num_carr; i++)
        {
            int tmp_band_select = carrierConfigsOut->carrierCfgs.bandSelect[i];
            resrc_prm.dlyPrev[i]   = prms->carrierComponents[i].halfBand.pipe;
            resrc_prm.clkPeriod[i] = (carr_num_hb[i] > hb) ? (resrc_prm.clkPeriod[i] << 1u) : (band_clk_period[tmp_band_select] << 1u);
            pre_stage_carr_en |= (carr_num_hb[i] >= hb) ? (carrierConfigsOut->carriersEnabled & (1u << i)) : 0u;
        }
        for (i = 0u; i < num_carr; i++)
        {
            if (carr_num_hb[i] >= hb)
            {
                mask = (hb < ADRV904X_NO_OF_HALF_BAND_DELAYS) ? 0xFFu : (i < (ADI_ADRV904X_MAX_CARRIERS >> 1u)) ? 0x0Fu : 0xF0u;
                prms->carrierComponents[i].halfBand.pipe += resourceShareDelay(device, &resrc_prm, (pre_stage_carr_en & mask), 1u, i) + hb_additional_pipe_delay;
            }
        }
    }

    /* Accounting for resource share block used for gain multiplier */
    for (i = 0u; i < num_carr; i++)
    {
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            prms->carrierComponents[i].cfilt.pipe = cfiltPipeDelay((uint8_t)carrierChannelFilter->bypassFilter[i], jesdClkPeriod, carrierChannelFilter->dataPipeStop[i], prms->carrSamplePeriod_cc[i]);
            resrc_prm.dlyPrev[i] =
                prms->carrierComponents[i].cfilt.pipe +
                prms->carrierComponents[i].halfBand.pipe +
                1u;
            resrc_prm.clkPeriod[i] = prms->carrSamplePeriod_cc[i];
        }
    }
    for (i = 0u; i < num_carr; i++)
    {
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            prms->carrierComponents[i].gainResrc = resourceShareDelay(device, &resrc_prm, (int)carrierConfigsOut->carriersEnabled, jesdClkPeriod, i);
        }
    }

    /* hb filters, channel filter, interleaver delays */
    uint32_t max_carr_delay = 0u;
    for (i = 0u; i < num_carr; i++)
    {
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            if (carrierChannelFilter->bypassFilter[i] == 0u)
            {
                /* use zero padded channel filter tap count here */
                tap_number = carrierChannelFilter->oddFilterTaps[i] ? carrierChannelFilter->numberOfFilterTaps[i] - 1u : carrierChannelFilter->numberOfFilterTaps[i];
                prms->carrierComponents[i].cfilt.tap = filterDelay(tap_number, prms->carrSamplePeriod_cc[i]);
            }
            prms->carrierComponents[i].halfBand.tap = hbFilterDelay(carr_num_hb[i], prms->carrSamplePeriod_cc[i]);
            prms->carrierComponents[i].deinterleaver = interleaverDelay(carr_interleaver_slot[i], jesdClkPeriod);

            /* sum of carrier group delay (CDDC alone) */
            prms->groupDelayCarr_cc[i] = 
                prms->carrierComponents[i].cfilt.tap +
                prms->carrierComponents[i].cfilt.pipe +
                prms->carrierComponents[i].halfBand.tap +
                prms->carrierComponents[i].halfBand.pipe +
                1u;

            /* Sum of (BandDDC + CDDC) to get combined group delay, which determines starting points when matching/minimizing skew between carriers */
            int tmp_band_select = carrierConfigsOut->carrierCfgs.bandSelect[i];
            prms->groupDelayBand_cc[i] = band_latencies_cc[tmp_band_select];
            prms->groupDelayComb_cc[i] = prms->groupDelayBand_cc[i] + prms->groupDelayCarr_cc[i];

            /* Track max( prms->groupDelayComb_cc[i] ) */
            max_carr_delay = (max_carr_delay > prms->groupDelayComb_cc[i]) ? max_carr_delay : prms->groupDelayComb_cc[i];
        }
        else
        {
            /* Zero out group delay results for disabled carriers */
            prms->groupDelayBand_cc[i] = 0u;
            prms->groupDelayCarr_cc[i] = 0u;
            prms->groupDelayComb_cc[i] = 0u;
        }
    }


    /* Calculate hsdigclk from sample rate */
    uint64_t hsdigclk_calc_kHz = 0;
    uint64_t max_hsdigclk_kHz = 0;
    for (int cc = 0; cc < prms->noOfCarriers; cc++)
    {
            
        for (int n = 0; hsdigclk_calc_kHz < hsdigclk_limit; ++n)
        {
            hsdigclk_calc_kHz = carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[cc] * (1 << n);
            max_hsdigclk_kHz = hsdigclk_calc_kHz < hsdigclk_limit ? hsdigclk_calc_kHz : max_hsdigclk_kHz;
        }
    }

    /* Set target delays, and offset_ideal_cc[i]
     *      - if user-provided custom delay value == 0, use target[i] = max_carr_delay of all enabled carriers found above
     *      - if user-provided custom delay value != 0, use target[i] = custom[i] as long as custom[i] >= groupDelayComb_cc[i]
     */
    for (i = 0u; i < num_carr; i++)
    {
        if (carrierConfigsOut->carrierCfgs.carrierEnable[i] > 0u)
        {
            uint64_t tmp_lat = carrierConfigsIn->carriers[i].absLatencyOverride_ns;
            tmp_lat *= max_hsdigclk_kHz;
            tmp_lat <<= 1u;
            tmp_lat /= 1000000;
            tmp_lat += 1u;
            tmp_lat >>= 1u;
                
            uint16_t custom_target_cc = (uint16_t)(tmp_lat);

            if (custom_target_cc == 0)
            {
                prms->targetDelay_cc[i] = max_carr_delay;
            }
            else if (custom_target_cc < prms->groupDelayComb_cc[i])
            {
                /* Check Latency Override is Possible */
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                ADI_VARIABLE_LOG(&device->common,
                    ADI_HAL_LOG_MSG,
                    "Latency Override %d ns --> %d cc for Carrier %d has to be larger than Calculated Group Delay Value %d cc",
                    carrierConfigsIn->carriers[i].absLatencyOverride_ns,
                    custom_target_cc,
                    i,
                    prms->groupDelayComb_cc[i]);
#endif
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, "Latency Override provided for a carrier must be larger than default latency calculation");
                return recoveryAction;
            }
            else
            {
                prms->targetDelay_cc[i] = custom_target_cc;
            }

            /* Calculate uncompensated offset b/w this carrier's actual group delay vs. target delay */
            prms->uncompOffset_cc[i] = prms->targetDelay_cc[i] - prms->groupDelayComb_cc[i];
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}


ADI_API adi_adrv904x_ErrAction_e adrv904x_CducDelayConfigurationCalculate(  adi_adrv904x_Device_t* const                        device, 
                                                                            const adi_adrv904x_CarrierRadioCfg_t* const         carrierConfigs,
                                                                            const adi_adrv904x_ChannelFilterOutputCfg_t* const  carrierChannelFilter,
                                                                            adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t i = 0U;
    uint32_t selectedChannel = 0U;
    uint32_t txIdx = 0U;
    
    adi_adrv904x_CarrierDelayParameters_t tmpDly;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierChannelFilter);

    ADI_LIBRARY_MEMSET(&tmpDly, 0, sizeof(tmpDly));
    
    /* Clear any delay prms values already stored in carrierConfigsOut */
    ADI_LIBRARY_MEMSET(&carrierConfigsOut->delayCfg, 0, sizeof(adi_adrv904x_CarrierDelayParameters_t));
    
    /* Pick a valid 'selectedChannel' so that it can used to index into extracted values taken from FW device profile binary */
    for (i = 0; i < ADI_ADRV904X_MAX_TXCHANNELS; i++)
    {
        if ((carrierConfigs->channelMask & (1 << i)) > 0)
        {
            selectedChannel = i;
            break;
        }
    }

    /* invoke design provided group delay solving algorithm: */
    /* This function will initialize tmpDly structure: */
    recoveryAction = adrv904x_CalculateCducDelayMatch(device, selectedChannel, carrierConfigs, carrierConfigsOut, carrierChannelFilter, &tmpDly);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    /* invoke the common group delay solving algorithm */
    recoveryAction = adrv904x_CalculateCommonDelayParameters(device, carrierConfigs, carrierConfigsOut, &tmpDly);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    /* transfer the solved parameters to the output data structure: tmpDly --> cduc output */
    ADI_LIBRARY_MEMCPY(&carrierConfigsOut->delayCfg, &tmpDly, sizeof(adi_adrv904x_CarrierDelayParameters_t));
    
    /* Store these latest Solved delays in device handle */
    for (txIdx = 0U; txIdx < ADI_ADRV904X_MAX_TXCHANNELS; txIdx++)
    {
        if ((carrierConfigs->channelMask & (1U << txIdx)) > 0U)
        {
            /* TPGSWE-7944: Store calculated latency into device profile */
            uint32_t clkCddcCducInkHz = tmpDly.jesdFrequency_kHz * pow(2, tmpDly.clkToJesdRatioLog2);
            device->devStateInfo.txCarrierLatencySolved.channel[txIdx].clkCddcCducInkHz = clkCddcCducInkHz;

            for (uint8_t carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                device->devStateInfo.txCarrierLatencySolved.channel[txIdx].groupDelay[carrierIdx] = tmpDly.groupDelayComb_cc[carrierIdx];
            }
        }
        else
        {
            ADI_LIBRARY_MEMSET(&device->devStateInfo.txCarrierLatencySolved.channel[txIdx], 0, sizeof(adi_adrv904x_CarrierReconfigLatencyCfg_t));
        }
    }

    return recoveryAction; 
}


ADI_API adi_adrv904x_ErrAction_e adrv904x_CddcDelayConfigurationCalculate(  adi_adrv904x_Device_t* const                        device, 
                                                                            const adi_adrv904x_CarrierRadioCfg_t* const         carrierConfigs,
                                                                            const adi_adrv904x_ChannelFilterOutputCfg_t* const  carrierChannelFilter,                                                         
                                                                            adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  carrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t i = 0U;
    uint32_t selectedChannel = 0U;
    uint32_t rxIdx = 0U;
    
    adi_adrv904x_CarrierDelayParameters_t tmpDly;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierChannelFilter);

    ADI_LIBRARY_MEMSET(&tmpDly, 0, sizeof(tmpDly));
    
    /* Clear any delay prms values already stored in carrierConfigsOut */
    ADI_LIBRARY_MEMSET(&carrierConfigsOut->delayCfg, 0, sizeof(adi_adrv904x_CarrierDelayParameters_t));
    
    /* Pick a valid 'selectedChannel' so that it can used to index into extracted values taken from FW device profile binary */
    for (i = 0; i < ADI_ADRV904X_MAX_TXCHANNELS; i++)
    {
        if ((carrierConfigs->channelMask & (1 << i)) > 0)
        {
            selectedChannel = i;
            break;
        }
    }

    /* invoke design provided group delay solving algorithm: */
    /* This function will initialize tmpDly structure: */
    recoveryAction = adrv904x_CalculateCddcDelayMatch(device, selectedChannel, carrierConfigs, carrierConfigsOut, carrierChannelFilter, &tmpDly);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    /* invoke the common group delay solving algorithm */
    recoveryAction = adrv904x_CalculateCommonDelayParameters(device, carrierConfigs, carrierConfigsOut, &tmpDly);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    /* transfer the solved parameters to the output data structure: tmpDly --> cduc output */
    ADI_LIBRARY_MEMCPY(&carrierConfigsOut->delayCfg, &tmpDly, sizeof(adi_adrv904x_CarrierDelayParameters_t));
    
    /* Store these latest Solved delays in device handle */
    for (rxIdx = 0U; rxIdx < ADI_ADRV904X_MAX_RX_ONLY; rxIdx++)
    {
        if ((carrierConfigs->channelMask & (1U << rxIdx)) > 0U)
        {
            /* TPGSWE-7944: Store calculated latency into device profile */
            uint32_t clkCddcCducInkHz = tmpDly.jesdFrequency_kHz * pow(2, tmpDly.clkToJesdRatioLog2);
            device->devStateInfo.rxCarrierLatencySolved.channel[rxIdx].clkCddcCducInkHz = clkCddcCducInkHz;

            for (uint8_t carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                device->devStateInfo.rxCarrierLatencySolved.channel[rxIdx].groupDelay[carrierIdx] = tmpDly.groupDelayComb_cc[carrierIdx];
            }
        }
        else
        {
            ADI_LIBRARY_MEMSET(&device->devStateInfo.rxCarrierLatencySolved.channel[rxIdx], 0, sizeof(adi_adrv904x_CarrierReconfigLatencyCfg_t));
        }
    }

    return recoveryAction; 
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_ReconfigSolutionInit( adi_adrv904x_Device_t* const                device,
                                                                const adi_adrv904x_CarrierJesdCfg_t* const  inJesdCfg,
                                                                const adi_adrv904x_CarrierRadioCfg_t        inProfileCfgs[],
                                                                uint32_t                                    inNumProfiles,
                                                                adi_adrv904x_CarrierReconfigSoln_t* const   soln)
{    
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t i = 0U;
    uint32_t j = 0U;
    uint32_t p = 0U;
    
    

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, inJesdCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, inProfileCfgs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, soln);
    
    if (inNumProfiles > ADI_ADRV904X_MAX_NUM_PROFILES)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, inNumProfiles, "Up to four profiles allowed.");
        return recoveryAction;
    }
    
    /* Clear entire soln structure */
    ADI_LIBRARY_MEMSET(soln, 0, sizeof(adi_adrv904x_CarrierReconfigSoln_t));
    
    /* Copy input data into solution structure */
    ADI_LIBRARY_MEMCPY(&soln->inputs.jesdCfg, inJesdCfg, sizeof(adi_adrv904x_CarrierJesdCfg_t));
    soln->inputs.numProfiles = inNumProfiles;
    for (int i = 0U; i < (int)soln->inputs.numProfiles; i++)
    {
        /* Copy the single profile if caller indicated it was populated */
        ADI_LIBRARY_MEMCPY(&soln->inputs.profileCfgs[i], &inProfileCfgs[i], sizeof(adi_adrv904x_CarrierRadioCfg_t));
    }
    
    /* Initialize output data for JESD and carrier profiles */
    for (i = 0U; i < ADI_ADRV904X_MAX_CARRIER_LINKS; i++)
    {
        for (j = 0U; j < ADI_ADRV904X_MAX_CARRIER_SLOTS; j++)
        {
            soln->outputs.jesdCfg.linkCfg[i].jesdCfg[j].channelSelect = 0U;
            soln->outputs.jesdCfg.linkCfg[i].jesdCfg[j].carrierSelect = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
            soln->outputs.jesdCfg.linkCfg[i].jesdCfg[j].slotSelect    = ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        }
    }

    for (p = 0U; p < ADI_ADRV904X_MAX_NUM_PROFILES; p++)
    {
        for (i = 0U; i < ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; i++)
        {
            soln->outputs.profileCfgs[p].internalJesdCfg.ifaceSlotTable[i] = (uint16_t)ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        }

        for (i = 0U; i < ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
        {
            soln->outputs.profileCfgs[p].internalJesdCfg.slotTable[i] = (uint16_t)ADI_ADRV904X_CARRIER_UNUSED_CC_XBAR;
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}



ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierJesdParametersCalculate(   adi_adrv904x_Device_t* const                            device,
                                                                            const adrv904x_CarrierInitialCfg_t* const               initialCfg,
                                                                            const adi_adrv904x_CarrierRadioCfg_t* const             carrierConfigs,
                                                                            adi_adrv904x_CarrierReconfigProfileCfgOut_t* const      carrierConfigsOut,
                                                                            const uint8_t                                           rxFlag)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t carrierIdx = 0U;
    uint32_t sumCarriersKhz = 0U;
    uint32_t minCarriersKhz = UINT32_MAX;
    uint32_t minIfaceKhz = ADRV904X_JESD_IQ_RATE_KHZ;
    uint32_t ratio = 0U;
    uint16_t numSlotComp = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);

    for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
    {
        if (carrierConfigs->carriers[carrierIdx].sampleRate_kHz > 0U)
        {
            if (rxFlag == ADI_TRUE)
            {
                carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx]       = adrv904x_SampleRateJesdIqRatioCalculate(carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx]          = adrv904x_CarrierBandSampleRateRatioCalculate(initialCfg->bandSettings[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]].sampleRate_kHz, carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx]   = carrierConfigs->carriers[carrierIdx].sampleRate_kHz << carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx];
            }
            else if (rxFlag == ADI_FALSE)
            {
                carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx]          = adrv904x_SampleRateJesdIqRatioCalculate(carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx]       = adrv904x_CarrierBandSampleRateRatioCalculate(initialCfg->bandSettings[carrierConfigsOut->carrierCfgs.bandSelect[carrierIdx]].sampleRate_kHz, carrierConfigs->carriers[carrierIdx].sampleRate_kHz);
                carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx]    = carrierConfigs->carriers[carrierIdx].sampleRate_kHz << carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx];
            }
            else
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxFlag, "Invalid rxFlag");
                return recoveryAction;
            }

            carrierConfigsOut->carrierCfgs.carrierRateRatio[carrierIdx] = adrv904x_CarrierRateCalculate(device->initExtract.clocks.hsDigClk_kHz, carrierConfigs->carriers[carrierIdx].sampleRate_kHz);

            sumCarriersKhz += carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx];
            minCarriersKhz = carrierConfigs->carriers[carrierIdx].sampleRate_kHz < minCarriersKhz ? carrierConfigs->carriers[carrierIdx].sampleRate_kHz : minCarriersKhz;
        }
        else
        {
            carrierConfigsOut->carrierCfgs.interpolationRatio[carrierIdx]                       = 0U;
            carrierConfigsOut->carrierCfgs.decimationRatio[carrierIdx]                          = 0U;
            carrierConfigsOut->carrierCfgs.carrierRateRatio[carrierIdx]                         = 0U;
            carrierConfigsOut->internalJesdCfg.jesdSampleRate_kHz[carrierIdx]    = 0U;
        }
    }
    
    /* error checking */
    if (sumCarriersKhz > device->initExtract.clocks.hsDigClk_kHz)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, sumCarriersKhz, "Aggregate carrier output sample rate exceeds the maximum value");
        return recoveryAction;
    }

    if (sumCarriersKhz == 0U)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, sumCarriersKhz, "Invalid Configuration Parameter");
        return recoveryAction; 
    }

    ratio = device->initExtract.clocks.hsDigClk_kHz / sumCarriersKhz;
    carrierConfigsOut->internalJesdCfg.divide = 0U;

    while (ratio > 1U)
    {
        carrierConfigsOut->internalJesdCfg.divide++;
        ratio >>= 1U;
    }
    carrierConfigsOut->internalJesdCfg.frequencyKhz = device->initExtract.clocks.hsDigClk_kHz >> carrierConfigsOut->internalJesdCfg.divide;

    if (carrierConfigsOut->internalJesdCfg.frequencyKhz > ADRV904X_JESD_INTERFACE_MAX_FREQ_KHZ)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT( &device->common,
                                recoveryAction,
                                carrierConfigsOut->internalJesdCfg.frequencyKhz,
                                "Component Carrier JESD interface rate exceeds the maximum value of 500000 kHz");
        return recoveryAction;
    }

    carrierConfigsOut->internalJesdCfg.numSlots = carrierConfigsOut->internalJesdCfg.frequencyKhz / minIfaceKhz;
    carrierConfigsOut->internalJesdCfg.initSlot = 0u;
    carrierConfigsOut->internalJesdCfg.maxSlot = carrierConfigsOut->internalJesdCfg.initSlot + carrierConfigsOut->internalJesdCfg.numSlots;
    
    
    /* Configurator changed to use input arg 8/16 instead of hardcoded 8 (for Tx Slot shuffling to manipulate the JESD clk rate to improve slot resolution (4ns --> 2ns)
     * API was using initialCfg value. Need to change minNumSLots before calling into this function
     */
    if (rxFlag == 1u)
    {
        numSlotComp = initialCfg->maxSlot;
    }
    else
    {
        /* only need to look at minNumSlots passed into this function in the case of forcing from 8 --> 16 for increasing JESD rate from 245M --> 491M
         * numSlotComp = carrierConfigsOut->internalJesdCfg.minNumSlots; 
         */
        
        /* Until we need that functionality, continue to use maxSlot from the initital cfg */
        numSlotComp = initialCfg->maxSlot;
    }
    
    /* Logs for seeing interface slots used (8 vs 16) by initCfg vs.  calculated value required here */
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "adrv904x_CarrierJesdParametersCalculate() :: Initital Cfg JESD Iface Max Slots (8 or 16) = %d", initialCfg->maxSlot);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "adrv904x_CarrierJesdParametersCalculate() :: Set numSlotComp = %d", numSlotComp);
#endif
    if (carrierConfigsOut->internalJesdCfg.numSlots < numSlotComp)           
    {
        carrierConfigsOut->internalJesdCfg.numSlots = numSlotComp;
        carrierConfigsOut->internalJesdCfg.frequencyKhz = carrierConfigsOut->internalJesdCfg.numSlots * minIfaceKhz;

        /* update jesd clk divider*/
        if (carrierConfigsOut->internalJesdCfg.frequencyKhz == 0U)
        {
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierConfigsOut->internalJesdCfg.frequencyKhz, "Invalid Configuration Parameter");
            return recoveryAction;
        }

        ratio = device->initExtract.clocks.hsDigClk_kHz / carrierConfigsOut->internalJesdCfg.frequencyKhz;
        carrierConfigsOut->internalJesdCfg.divide = 0U;

        while (ratio > 1U)
        {
            carrierConfigsOut->internalJesdCfg.divide++;
            ratio >>= 1U;
        }
    }
    else if (carrierConfigsOut->internalJesdCfg.numSlots > initialCfg->maxSlot)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT( &device->common,
                                recoveryAction,
                                carrierConfigsOut->internalJesdCfg.numSlots,
                                "Cannot exceed the max slots used during initialization. Try initializing with a more robust profile created specifically for reconfiguring.");
        return recoveryAction;
    }

    /* Checking for maximum JESD iface slot value is in calculate_carrier_jesd_iface_slot_table */
    carrierConfigsOut->internalJesdCfg.ifaceMaxSlot = carrierConfigsOut->internalJesdCfg.numSlots;

    if (minCarriersKhz == 0U)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, minCarriersKhz, "Invalid Configuration Parameter");
        return recoveryAction;
    }
    
    if (minIfaceKhz > minCarriersKhz)
    {
        carrierConfigsOut->internalJesdCfg.numSlots = (minIfaceKhz / minCarriersKhz);
        carrierConfigsOut->internalJesdCfg.numSlots *= carrierConfigsOut->internalJesdCfg.ifaceMaxSlot;
    }

    if (carrierConfigsOut->internalJesdCfg.ifaceMaxSlot > ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierConfigsOut->internalJesdCfg.ifaceMaxSlot, "Number of Component Carrier Slots exceeds maximum");
        return recoveryAction;
    }

    recoveryAction = adrv904x_CarrierJesdSlotTableCalculate(device, carrierConfigs, carrierConfigsOut);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    /* Calculate maxSlot and initSlot */
    carrierConfigsOut->internalJesdCfg.maxSlot = carrierConfigsOut->internalJesdCfg.numSlots;
    carrierConfigsOut->internalJesdCfg.initSlot = 0;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierBandSorting( adi_adrv904x_Device_t* const                        device,
                                                                const adrv904x_CarrierInitialCfg_t* const           rxInitialCfg,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const         rxCarrierConfigs,
                                                                adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  rxCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigsOut);

    uint32_t band0LowerEdgeKhz      = rxInitialCfg->bandSettings[0U].rfCenterFreq_kHz - rxInitialCfg->bandSettings[0U].instBw_kHz / 2U;
    uint32_t band0UpperEdgeKhz      = rxInitialCfg->bandSettings[0U].rfCenterFreq_kHz + rxInitialCfg->bandSettings[0U].instBw_kHz / 2U;
    uint32_t band1LowerEdgeKhz      = rxInitialCfg->bandSettings[1U].rfCenterFreq_kHz - rxInitialCfg->bandSettings[1U].instBw_kHz / 2U;
    uint32_t band1UpperEdgeKhz      = rxInitialCfg->bandSettings[1U].rfCenterFreq_kHz + rxInitialCfg->bandSettings[1U].instBw_kHz / 2U;
    uint32_t carrierLowerEdgeKhz    = 0U;
    uint32_t carrierUpperEdgeKhz    = 0U;
    uint32_t idx                    = 0U;

    for (idx = 0; idx < ADI_ADRV904X_MAX_RX_CARRIERS; idx++)
    {
        if (rxCarrierConfigs->carriers[idx].enable)
        {
            rxCarrierConfigsOut->carriersEnabled |= (1 << idx);
            rxCarrierConfigsOut->carrierCfgs.carrierEnable[idx] = 1u;

            carrierLowerEdgeKhz = rxCarrierConfigs->carriers[idx].centerFrequency_kHz - rxCarrierConfigs->carriers[idx].ibw_kHz / 2;
            carrierUpperEdgeKhz = rxCarrierConfigs->carriers[idx].centerFrequency_kHz + rxCarrierConfigs->carriers[idx].ibw_kHz / 2;

            if ((carrierLowerEdgeKhz >= band0LowerEdgeKhz) && (carrierUpperEdgeKhz <= band0UpperEdgeKhz))
            {
                rxCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 0U;
            }
            else if ((carrierLowerEdgeKhz >= band1LowerEdgeKhz) && (carrierUpperEdgeKhz <= band1UpperEdgeKhz))
            {
                rxCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 1U;
            }
            else
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxCarrierConfigs->carriers[idx].ibw_kHz, "Carrier is outside band");
                return recoveryAction;
            }
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierNcoReconfig( adi_adrv904x_Device_t* const                            device,
                                                                const adrv904x_CarrierInitialCfg_t* const               rxInitialCfg,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const             rxCarrierConfigs,
                                                                adi_adrv904x_CarrierReconfigProfileCfgOut_t* const      rxCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t idx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigsOut);

    for (idx = 0; idx < ADI_ADRV904X_MAX_RX_CARRIERS; idx++)
    {
        if (rxCarrierConfigs->carriers[idx].enable)
        {
            rxCarrierConfigsOut->carrierCfgs.outputRate_kHz[idx]    = rxInitialCfg->bandSettings[rxCarrierConfigsOut->carrierCfgs.bandSelect[idx]].sampleRate_kHz;
            rxCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx]       = rxCarrierConfigs->carriers[idx].centerFrequency_kHz
                                                                        - rxInitialCfg->bandSettings[rxCarrierConfigsOut->carrierCfgs.bandSelect[idx]].rfCenterFreq_kHz
                                                                        + rxInitialCfg->bandSettings[rxCarrierConfigsOut->carrierCfgs.bandSelect[idx]].bandOffset_kHz;

            rxCarrierConfigsOut->carrierCfgs.mixerEnable[idx]       = (rxCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx] != 0) ? 1U : 0U;
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierDelaySet(    adi_adrv904x_Device_t* const device,
                                                                const uint8_t chanSelect,
                                                                const adi_adrv904x_CarrierHwDelayBufferConfig_t* const rxHwDelayBufferConfig)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t rxSel = 0U;
    adrv904x_BfCddcHbDpathChanAddr_e cddcHbDpathChanBaseAddr = ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t delayRegisterIdx = 0U;
    uint32_t delayIdx = 0U;
    uint32_t delayRegOffset = ADRV904X_ADDR_RX0_CDDC_DELAY_0 - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t delayRegAddr = 0U;
    uint32_t delayRegisterValue = 0U;
    uint32_t fifoSelectIdx = 0U;
    const uint32_t DELAY_VAL_MASK = 0x1FFU;
    const uint32_t DELAY_VAL_SHIFT = 16U;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxHwDelayBufferConfig);   

    /* Convert the rxSel to the base address value required by the bitfield functions */
    rxSel = 1U << chanSelect;
    recoveryAction = adrv904x_CddcHbDpathBitfieldAddressGet(device, (adi_adrv904x_RxChannels_e)(rxSel), &cddcHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CddcHbDpath_DelayCmpEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->cmpEn);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_DelayMemEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->memEn);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_DaisyChainEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->daisyEn);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect0_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect1_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect2_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect3_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect4_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect5_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect6_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CddcHbDpath_CarrierSelect7_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    /* HBDpath base + SlotValue0 offset */
    delayRegAddr = (uint32_t)cddcHbDpathChanBaseAddr + delayRegOffset;
    for (delayRegisterIdx = 0U; delayRegisterIdx < (ADI_ADRV904X_NO_OF_CARRIER_DELAY_FIFOS >> 1); delayRegisterIdx++)
    {
        delayRegisterValue = ((uint32_t)rxHwDelayBufferConfig->delayValue[delayIdx++] & DELAY_VAL_MASK);
        delayRegisterValue |= ((uint32_t)(rxHwDelayBufferConfig->delayValue[delayIdx++] & DELAY_VAL_MASK) << DELAY_VAL_SHIFT);

        recoveryAction = adi_adrv904x_Register32Write(device, NULL, delayRegAddr, delayRegisterValue, 0xFFFFFFFFU);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
        delayRegAddr += 4U;
    }
    
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_RxCarrierConfigSet( adi_adrv904x_Device_t* const                                  device,
                                                                const uint8_t                                               chanSelect,
                                                                const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    rxCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    adrv904x_BfCddcHbDpathChanAddr_e cddcHbDpathChanBaseAddr = ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t rxSel = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);

    if (chanSelect > (ADI_ADRV904X_MAX_RX_ONLY - 1U))
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, chanSelect, "Invalid RX Channel");
        return recoveryAction; 
    }

    /* Convert the rxSel to the base address value required by the bitfield functions */
    rxSel = 1U << chanSelect;
    recoveryAction = adrv904x_CddcHbDpathBitfieldAddressGet(device, (adi_adrv904x_RxChannels_e)(rxSel), &cddcHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CddcHbDpath_CarrierEnable_BfSet(device, NULL, cddcHbDpathChanBaseAddr, rxCarrierConfigs->carriersEnabled);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    for (carrierIdx = 0; carrierIdx < ADI_ADRV904X_MAX_RX_CARRIERS; carrierIdx++)
    {
        recoveryAction = adrv904x_CddcHbDpath_OneMsClocks_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.outputRate_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_BandSource_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, (adrv904x_Bf_CddcHbDpath_BandSource_e)rxCarrierConfigs->carrierCfgs.bandSelect[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_FreqKhz_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.ncoFreq_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_NcoFtwUpdate_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, 1U);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_NcoEnable_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CddcHbDpath_MixerEn_BfSet(device, NULL, cddcHbDpathChanBaseAddr, carrierIdx, rxCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierBandSorting( adi_adrv904x_Device_t* const                        device,
                                                                const adrv904x_CarrierInitialCfg_t* const           txInitialCfg,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const         txCarrierConfigs,
                                                                adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  txCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigsOut);

    uint32_t band0LowerEdgeKhz      = txInitialCfg->bandSettings[0U].rfCenterFreq_kHz - txInitialCfg->bandSettings[0U].instBw_kHz / 2U;
    uint32_t band0UpperEdgeKhz      = txInitialCfg->bandSettings[0U].rfCenterFreq_kHz + txInitialCfg->bandSettings[0U].instBw_kHz / 2U;
    uint32_t band1LowerEdgeKhz      = txInitialCfg->bandSettings[1U].rfCenterFreq_kHz - txInitialCfg->bandSettings[1U].instBw_kHz / 2U;
    uint32_t band1UpperEdgeKhz      = txInitialCfg->bandSettings[1U].rfCenterFreq_kHz + txInitialCfg->bandSettings[1U].instBw_kHz / 2U;
    uint32_t carrierLowerEdgeKhz    = 0U;
    uint32_t carrierUpperEdgeKhz    = 0U;
    uint32_t idx                    = 0U;

    for (idx = 0; idx < ADI_ADRV904X_MAX_CARRIERS; idx++)
    {
        if (txCarrierConfigs->carriers[idx].enable)
        {
            txCarrierConfigsOut->carriersEnabled |= (1 << idx);
            txCarrierConfigsOut->carrierCfgs.carrierEnable[idx] = 1u;

            carrierLowerEdgeKhz = txCarrierConfigs->carriers[idx].centerFrequency_kHz - txCarrierConfigs->carriers[idx].ibw_kHz / 2;
            carrierUpperEdgeKhz = txCarrierConfigs->carriers[idx].centerFrequency_kHz + txCarrierConfigs->carriers[idx].ibw_kHz / 2;

            if ((carrierLowerEdgeKhz >= band0LowerEdgeKhz) && (carrierUpperEdgeKhz <= band0UpperEdgeKhz))
            {
                txCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 0U;
            }
            else if ((carrierLowerEdgeKhz >= band1LowerEdgeKhz) && (carrierUpperEdgeKhz <= band1UpperEdgeKhz))
            {
                txCarrierConfigsOut->carrierCfgs.bandSelect[idx] = 1U;
            }
            else
            {
                recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
                ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, txCarrierConfigs->carriers[idx].ibw_kHz, "Carrier is outside band");
                return recoveryAction;
            }
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierNcoReconfig( adi_adrv904x_Device_t* const                        device,
                                                                const adrv904x_CarrierInitialCfg_t* const           txInitialCfg,
                                                                const adi_adrv904x_CarrierRadioCfg_t* const         txCarrierConfigs,
                                                                adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  txCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t idx = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigsOut);

    for (idx = 0; idx < ADI_ADRV904X_MAX_CARRIERS; idx++)
    {
        if (txCarrierConfigs->carriers[idx].enable)
        {
            txCarrierConfigsOut->carrierCfgs.outputRate_kHz[idx] = txInitialCfg->bandSettings[txCarrierConfigsOut->carrierCfgs.bandSelect[idx]].sampleRate_kHz;
            txCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx] = txCarrierConfigs->carriers[idx].centerFrequency_kHz - txInitialCfg->bandSettings[txCarrierConfigsOut->carrierCfgs.bandSelect[idx]].rfCenterFreq_kHz;
            txCarrierConfigsOut->carrierCfgs.mixerEnable[idx] = (txCarrierConfigsOut->carrierCfgs.ncoFreq_kHz[idx] != 0) ? 1U : 0U;
        }
    }

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierBandAttenConfig( adi_adrv904x_Device_t* const                        device,
                                                                    const adi_adrv904x_CarrierRadioCfg_t* const         txCarrierConfigs,
                                                                    adi_adrv904x_CarrierReconfigProfileCfgOut_t* const  txCarrierConfigsOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t idx = 0U;

    uint8_t carrierCnt = 0U;
    uint16_t attenVals[] = 
    {
        181U,   /* 256.0 / sqrt(2) */
        147U,   /* 256.0 / sqrt(3) */
        128U,   /* 256.0 / sqrt(4) */
        114U,   /* 256.0 / sqrt(5) */
        104U,   /* 256.0 / sqrt(6) */
        96U,    /* 256.0 / sqrt(7) */
        90U,    /* 256.0 / sqrt(8) */
    };

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigsOut);

    for (idx = 0; idx < ADI_ADRV904X_MAX_CARRIERS; idx++)
    {
        if (txCarrierConfigs->carriers[idx].enable)
        {
            carrierCnt++;
        }
    }

    /* Use pre-calculated atten values in the array offset by two for correct indexing */
    txCarrierConfigsOut->band0Atten = (carrierCnt > 1U) ? attenVals[carrierCnt - 2U] : UINT16_MAX;

    /* Band attenuation value must match to ensure full scale is not exceeded after the summation of DUC0 and DUC 1 */
    txCarrierConfigsOut->band1Atten = txCarrierConfigsOut->band0Atten;

    recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierDelaySet(    adi_adrv904x_Device_t* const device,
                                                                const uint8_t chanSelect,
                                                                const adi_adrv904x_CarrierHwDelayBufferConfig_t* const txHwDelayBufferConfig)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t txSel = 0U;
    adrv904x_BfCducHbDpathChanAddr_e cducHbDpathChanBaseAddr = ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t delayRegisterIdx = 0U;
    uint32_t delayIdx = 0U;
    uint32_t delayRegOffset = ADRV904X_ADDR_TX0_CDDC_DELAY_0 - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t delayRegAddr = 0U;
    uint32_t delayRegisterValue = 0U;
    uint32_t fifoSelectIdx = 0U;
    const uint32_t DELAY_VAL_MASK = 0x1FFU;
    const uint32_t DELAY_VAL_SHIFT = 16U;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txHwDelayBufferConfig);   

    /* Convert the txSel to the base address value required by the bitfield functions */
    txSel = 1U << chanSelect;
    recoveryAction = adrv904x_CducHbDpathBitfieldAddressGet(device, (adi_adrv904x_TxChannels_e)(txSel), &cducHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    

    recoveryAction = adrv904x_CducHbDpath_DelayCompEn_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->cmpEn);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_DelayMemEn_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->memEn);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_DaisyChainEn_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->daisyEn);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect0_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect1_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect2_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect3_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect4_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect5_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect6_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    recoveryAction = adrv904x_CducHbDpath_CarrierSelect7_BfSet(device, NULL, cducHbDpathChanBaseAddr, txHwDelayBufferConfig->carrierSelect[fifoSelectIdx++]);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    
    /* HBDpath base + SlotValue0 offset */
    delayRegAddr = (uint32_t)cducHbDpathChanBaseAddr + delayRegOffset;
    for (delayRegisterIdx = 0U; delayRegisterIdx < (ADI_ADRV904X_NO_OF_CARRIER_DELAY_FIFOS >> 1); delayRegisterIdx++)
    {
        delayRegisterValue = ((uint32_t)txHwDelayBufferConfig->delayValue[delayIdx++] & DELAY_VAL_MASK);
        delayRegisterValue |= ((uint32_t)(txHwDelayBufferConfig->delayValue[delayIdx++] & DELAY_VAL_MASK) << DELAY_VAL_SHIFT);

        recoveryAction = adi_adrv904x_Register32Write(device, NULL, delayRegAddr, delayRegisterValue, 0xFFFFFFFFU);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
        delayRegAddr += 4U;
    }
    
    return recoveryAction;
}
ADI_API adi_adrv904x_ErrAction_e adrv904x_TxCarrierConfigSet(   adi_adrv904x_Device_t* const                                device,
                                                                const uint8_t                                               chanSelect,
                                                                const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    txCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    adrv904x_BfCducHbDpathChanAddr_e cducHbDpathChanBaseAddr = ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t txSel = 0U;

    /* Check device pointer is not null */
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);

    if (chanSelect > ADI_ADRV904X_TX_CHAN_ID_MAX)
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, chanSelect, "Invalid TX Channel");
        return recoveryAction; 
    }

    /* Convert the txSel to the base address value required by the bitfield functions */
    txSel = 1U << chanSelect;
    recoveryAction = adrv904x_CducHbDpathBitfieldAddressGet(device, (adi_adrv904x_TxChannels_e)(txSel), &cducHbDpathChanBaseAddr);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    for (carrierIdx = 0; carrierIdx < ADI_ADRV904X_MAX_RX_CARRIERS; carrierIdx++)
    {
        recoveryAction = adrv904x_CducHbDpath_OneMsClocks_BfSet(device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                carrierIdx,
                                                                txCarrierConfigs->carrierCfgs.outputRate_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_BandDest_BfSet(   device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                carrierIdx,
                                                                (adrv904x_Bf_CducHbDpath_BandDest_e)txCarrierConfigs->carrierCfgs.bandSelect[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_FreqKhz_BfSet(device,
                                                            NULL,
                                                            cducHbDpathChanBaseAddr,
                                                            carrierIdx,
                                                            (uint32_t)txCarrierConfigs->carrierCfgs.ncoFreq_kHz[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_NcoFtwUpdate_BfSet(   device,
                                                                    NULL,
                                                                    cducHbDpathChanBaseAddr,
                                                                    carrierIdx,
                                                                    1U);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_NcoEnable_BfSet(  device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                carrierIdx,
                                                                txCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }

        recoveryAction = adrv904x_CducHbDpath_MixerEn_BfSet(device,
                                                            NULL,
                                                            cducHbDpathChanBaseAddr,
                                                            carrierIdx,
                                                            txCarrierConfigs->carrierCfgs.mixerEnable[carrierIdx]);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }

    recoveryAction = adrv904x_CducHbDpath_CarrBand0Attn_BfSet(  device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                txCarrierConfigs->band0Atten);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CducHbDpath_CarrBand1Attn_BfSet(  device,
                                                                NULL,
                                                                cducHbDpathChanBaseAddr,
                                                                txCarrierConfigs->band1Atten);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    recoveryAction = adrv904x_CducHbDpath_CducCarrierEnable_BfSet(  device,
                                                                    NULL,
                                                                    cducHbDpathChanBaseAddr,
                                                                    txCarrierConfigs->carriersEnabled);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}
ADI_API adi_adrv904x_ErrAction_e adrv904x_RxJesdConfigSet(  adi_adrv904x_Device_t* const                        device,
                                                            const adi_adrv904x_CarrierReconfigOutput_t* const   reconfigOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t linkIdx = 0U;
    uint8_t xbarControlIdx = 0U;
    uint32_t xbarControlMax = ADI_ADRV904X_MAX_CARRIER_SLOTS;
    uint32_t jtxConvDisable = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, reconfigOut);

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    {

        xbarControlMax = (linkIdx == 0U) ? ADI_ADRV904X_MAX_CARRIER_SLOTS : ADI_ADRV904X_MAX_CARRIER_SLOTS >> 1U;
        for (xbarControlIdx = 0U; xbarControlIdx < xbarControlMax; xbarControlIdx++)
        {
            if (reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect > ADRV904X_LAST_VALID_SLOT_SELECT_IN_CARRIER_MODE)
            {
                jtxConvDisable = 1U; /* 1 is an invalid entry */
            }
            else
            {
                jtxConvDisable = 0U; /* 0 is a valid entry */
            }
            
            if (linkIdx == 0U)
            {
                recoveryAction = adrv904x_JesdCommon_JtxCoreConvDisableLink0_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jtxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JtxChannelSelLink0_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].channelSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                
                recoveryAction = adrv904x_JesdCommon_Rx0ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                
                recoveryAction = adrv904x_JesdCommon_Rx1ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx2ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx3ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx4ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx5ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx6ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx7ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
            else
            {
                recoveryAction = adrv904x_JesdCommon_JtxCoreConvDisableLink1_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jtxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JtxChannelSelLink1_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].channelSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx0ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx1ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx2ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx3ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx4ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx5ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx6ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Rx7ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierRxJesdConfigSet(   adi_adrv904x_Device_t* const                                device,
                                                                    const uint32_t                                              rxChannelMask,
                                                                    const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    rxCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    adrv904x_BfCddcHbDpathChanAddr_e cddcHbDpathChanBaseAddr = ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t rxIdx = 0U;
    uint32_t rxSel = 0U;
    uint32_t slotRegisterIdx = 0U;
    uint32_t slotIdx = 0U;
    uint32_t slotAddr = 0U;
    uint32_t slotRegOffset = ADRV904X_ADDR_RX0_INTERLEAVER_SLOT_TABLE_0 - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_HB_DPATH;
    uint32_t slotRegisterValue = 0U;
    uint64_t tmpVal = 0U;
    adrv904x_BfCddcFuncsChanAddr_e cddcFuncAddr = (adrv904x_BfCddcFuncsChanAddr_e) 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, rxCarrierConfigs);

    /* rxChannelMask should larger than 0 and less than 0x100 */
    if ((rxChannelMask == 0U) ||
        ((rxChannelMask & (~(uint32_t)ADI_ADRV904X_RX_MASK_ALL)) != 0U))
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxChannelMask, "Invalid Rx channel mask");
        return recoveryAction;
    }

    for (rxIdx = 0U; rxIdx < ADI_ADRV904X_MAX_RX_ONLY; rxIdx++)
    {
        rxSel = 1U << rxIdx;
        if ((rxChannelMask & rxSel) > 0U)
        {
            cddcFuncAddr = (adrv904x_BfCddcFuncsChanAddr_e) (ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_FUNCS
                                                             + (ADRV904X_BF_SLICE_RX_1__RX_CDDC_RX_CDDC_FUNCS - ADRV904X_BF_SLICE_RX_0__RX_CDDC_RX_CDDC_FUNCS) * rxIdx);

            recoveryAction = adrv904x_CddcFuncs_CddcJesdClkDiv_BfSet(   device,
                                                                        NULL,
                                                                        cddcFuncAddr,
                                                                        (adrv904x_Bf_CddcFuncs_CddcJesdClkDiv_e)rxCarrierConfigs->internalJesdCfg.divide);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CddcHbDpathBitfieldAddressGet(device,
                                                                    (adi_adrv904x_RxChannels_e)(rxSel),
                                                                    &cddcHbDpathChanBaseAddr);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CddcHbDpath_InterleaverMaxSlot_BfSet( device,
                                                                            NULL,
                                                                            cddcHbDpathChanBaseAddr,
                                                                            rxCarrierConfigs->internalJesdCfg.ifaceMaxSlot);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            tmpVal = rxCarrierConfigs->internalJesdCfg.slotValid;
            tmpVal &= 0xFFFFFFFFull;
            recoveryAction = adrv904x_CddcHbDpath_InterleaverSlotValidLower_BfSet(  device,
                                                                                    NULL,
                                                                                    cddcHbDpathChanBaseAddr,
                                                                                    (uint32_t)tmpVal);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            tmpVal = rxCarrierConfigs->internalJesdCfg.slotValid >> 32;
            tmpVal &= 0xFFFFFFFFull;
            recoveryAction = adrv904x_CddcHbDpath_InterleaverSlotValidUpper_BfSet(  device,
                                                                                    NULL,
                                                                                    cddcHbDpathChanBaseAddr,
                                                                                    (uint32_t)tmpVal);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            /* HBDpath base + SlotValue0 offset */
            slotAddr = (uint32_t)cddcHbDpathChanBaseAddr + slotRegOffset;
            for (slotRegisterIdx = 0U; slotRegisterIdx < (ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS / ADRV904X_SLOTS_PER_REGISTER); slotRegisterIdx++)
            {
                slotRegisterValue = 0U;
                if (slotRegisterIdx < 2)
                {
                for (slotIdx = 0U; slotIdx < ADRV904X_SLOTS_PER_REGISTER; slotIdx++)
                {
                        slotRegisterValue |= (rxCarrierConfigs->internalJesdCfg.ifaceSlotTable[(slotRegisterIdx * ADRV904X_SLOTS_PER_REGISTER + slotIdx)] & 0xFU) << (4U * slotIdx);
                    } 
                }

                recoveryAction = adi_adrv904x_Register32Write(device, NULL, slotAddr, slotRegisterValue, 0xFFFFFFFFU);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                slotAddr += 4U;
            }

            for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                recoveryAction = adrv904x_CddcHbDpath_UpsamplerRatio_BfSet( device,
                                                                            NULL,
                                                                            cddcHbDpathChanBaseAddr,
                                                                            carrierIdx,
                                                                            (adrv904x_Bf_CddcHbDpath_UpsamplerRatio_e)rxCarrierConfigs->carrierCfgs.interpolationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_CddcHbDpath_DecRate_BfSet(device,
                                                                    NULL,
                                                                    cddcHbDpathChanBaseAddr,
                                                                    carrierIdx,
                                                                    (adrv904x_Bf_CddcHbDpath_DecRate_e)rxCarrierConfigs->carrierCfgs.decimationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_TxJesdConfigSet(  adi_adrv904x_Device_t* const                        device,
                                                            const adi_adrv904x_CarrierReconfigOutput_t* const   reconfigOut)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    uint32_t linkIdx = 0U;
    uint8_t xbarControlIdx = 0U;
    uint32_t xbarControlMax = ADI_ADRV904X_MAX_CARRIER_SLOTS;
    uint32_t jrxConvDisable = 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, reconfigOut);

    for (linkIdx = 0U; linkIdx < ADI_ADRV904X_MAX_CARRIER_LINKS; linkIdx++)
    {
        xbarControlMax = (linkIdx == 0U) ? ADI_ADRV904X_MAX_CARRIER_SLOTS : ADI_ADRV904X_MAX_CARRIER_SLOTS >> 1U;

        for (xbarControlIdx = 0U; xbarControlIdx < xbarControlMax; xbarControlIdx++)
        {
            if (reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect > ADRV904X_LAST_VALID_SLOT_SELECT_IN_CARRIER_MODE)
            {
                jrxConvDisable = 1U; /* 1 is an invalid entry */
            }
            else
            {
                jrxConvDisable = 0U; /* 0 is a valid entry */
            }

            if (linkIdx == 0U)
            {
                recoveryAction = adrv904x_JesdCommon_JrxCoreConvDisableLink0_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jrxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JrxChannelSelLink0_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].channelSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx0ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx1ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx2ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx3ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx4ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx5ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx6ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx7ChSampleSelLink0_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
            else
            {
                recoveryAction = adrv904x_JesdCommon_JrxCoreConvDisableLink1_BfSet( device,
                                                                                    NULL,
                                                                                    ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                    xbarControlIdx,
                                                                                    jrxConvDisable);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_JrxChannelSelLink1_BfSet(  device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].channelSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx0ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx1ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx2ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx3ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx4ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx5ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx6ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_JesdCommon_Tx7ChSampleSelLink1_BfSet( device,
                                                                                NULL,
                                                                                ADRV904X_BF_DIGITAL_CORE_JESD_JESD_COMMON,
                                                                                xbarControlIdx,
                                                                                reconfigOut->jesdCfg.linkCfg[linkIdx].jesdCfg[xbarControlIdx].slotSelect);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierTxJesdConfigSet(   adi_adrv904x_Device_t* const                                device,
                                                                    const uint32_t                                              txChannelMask,
                                                                    const adi_adrv904x_CarrierReconfigProfileCfgOut_t* const    txCarrierConfigs)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    adrv904x_BfCducHbDpathChanAddr_e cducHbDpathChanBaseAddr = ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t carrierIdx = 0U;
    uint32_t txIdx = 0U;
    uint32_t txSel = 0U;
    uint32_t slotRegisterIdx = 0U;
    uint32_t slotIdx = 0U;
    uint32_t slotAddr = 0U;
    uint32_t slotRegOffset = ADRV904X_ADDR_TX0_DEINTERLEAVER_SLOT_TABLE_0 - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_HB_DPATH;
    uint32_t slotRegisterValue = 0U;
    uint64_t tmpVal = 0U;
    adrv904x_BfCducFuncsChanAddr_e cducFuncAddr = (adrv904x_BfCducFuncsChanAddr_e) 0U;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, txCarrierConfigs);

    /* txChannelMask should larger than 0 and less than 0x100 */
    if ((txChannelMask == 0U) ||
        ((txChannelMask & (~(uint32_t)ADI_ADRV904X_TXALL)) != 0U))
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, txChannelMask, "Invalid Tx channel mask");
        return recoveryAction;
    }

    for (txIdx = 0U; txIdx < ADI_ADRV904X_MAX_TXCHANNELS; txIdx++)
    {
        txSel = 1U << txIdx;
        if ((txChannelMask & txSel) > 0U)
        {
            cducFuncAddr = (adrv904x_BfCducFuncsChanAddr_e) (ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_FUNCS
                                + (ADRV904X_BF_SLICE_TX_1__TX_CDUC_TX_CDUC_FUNCS - ADRV904X_BF_SLICE_TX_0__TX_CDUC_TX_CDUC_FUNCS) * txIdx);

            recoveryAction = adrv904x_CducFuncs_CducJesdClkDiv_BfSet(   device,
                                                                        NULL,
                                                                        cducFuncAddr,
                                                                        (adrv904x_Bf_CducFuncs_CducJesdClkDiv_e)txCarrierConfigs->internalJesdCfg.divide);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CducHbDpathBitfieldAddressGet(device,
                                                                    (adi_adrv904x_TxChannels_e)(txSel),
                                                                    &cducHbDpathChanBaseAddr);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            recoveryAction = adrv904x_CducHbDpath_DeinterleaverMaxSlot_BfSet(   device,
                                                                                NULL,
                                                                                cducHbDpathChanBaseAddr,
                                                                                txCarrierConfigs->internalJesdCfg.maxSlot);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            tmpVal = txCarrierConfigs->internalJesdCfg.slotValid;
            tmpVal &= 0xFFFFFFFFull;
            recoveryAction = adrv904x_CducHbDpath_DeinterleaverSlotValidLower_BfSet(device,
                                                                                    NULL,
                                                                                    cducHbDpathChanBaseAddr,
                                                                                    (uint32_t)tmpVal);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            tmpVal = txCarrierConfigs->internalJesdCfg.slotValid >> 32;
            tmpVal &= 0xFFFFFFFFull;
            recoveryAction = adrv904x_CducHbDpath_DeinterleaverSlotValidUpper_BfSet(device,
                                                                                    NULL,
                                                                                    cducHbDpathChanBaseAddr,
                                                                                    (uint32_t)tmpVal);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                return recoveryAction;
            }

            /* HBDpath base + SlotValue0 offset */
            slotAddr = (uint32_t)cducHbDpathChanBaseAddr + slotRegOffset;
            for (slotRegisterIdx = 0U; slotRegisterIdx < (ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS / ADRV904X_SLOTS_PER_REGISTER); slotRegisterIdx++)
            {
                slotRegisterValue = 0U;

                for (slotIdx = 0U; slotIdx < ADRV904X_SLOTS_PER_REGISTER; slotIdx++)
                {
                    slotRegisterValue |= (txCarrierConfigs->internalJesdCfg.slotTable[(slotRegisterIdx * ADRV904X_SLOTS_PER_REGISTER + slotIdx)] & 0xFU) << (4U * slotIdx);
                }

                recoveryAction = adi_adrv904x_Register32Write(device, NULL, slotAddr, slotRegisterValue, 0xFFFFFFFFU);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
                slotAddr += 4U;
            }

            for (carrierIdx = 0U; carrierIdx < ADI_ADRV904X_MAX_CARRIERS; carrierIdx++)
            {
                recoveryAction = adrv904x_CducHbDpath_DownsamplerRatio_BfSet(   device,
                                                                                NULL,
                                                                                cducHbDpathChanBaseAddr,
                                                                                carrierIdx,
                                                                                (adrv904x_Bf_CducHbDpath_DownsamplerRatio_e)txCarrierConfigs->carrierCfgs.decimationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_CducHbDpath_IntRate_BfSet(device,
                                                                    NULL,
                                                                    cducHbDpathChanBaseAddr,
                                                                    carrierIdx,
                                                                    (adrv904x_Bf_CducHbDpath_IntRate_e)txCarrierConfigs->carrierCfgs.interpolationRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }

                recoveryAction = adrv904x_CducHbDpath_CducClkToCarrierRate_BfSet(   device,
                                                                                    NULL,
                                                                                    cducHbDpathChanBaseAddr,
                                                                                    carrierIdx,
                                                                                    (adrv904x_Bf_CducHbDpath_CducClkToCarrierRate_e)txCarrierConfigs->carrierCfgs.carrierRateRatio[carrierIdx]);
                if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
                {
                    ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
                    return recoveryAction;
                }
            }
        }
    }

    
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_ChannelFilterCoefsGet(    adi_adrv904x_Device_t* const                        device,
                                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                                    const int16_t** const                               coeffTable,
                                                                    int16_t* const                                      coeffTableSize,
                                                                    uint32_t* const                                     numberOfFilterTaps,
                                                                    uint8_t* const                                      assymetricFilterTaps,
                                                                    const uint8_t                                       rxFlag)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);

    if (rxFlag == ADI_TRUE)
    {
        recoveryAction = cddc_assign_coefs(device, carrierChannelFilterApplicationSel, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }
    else if (rxFlag == ADI_FALSE)
    {
        recoveryAction = cduc_assign_coefs(device, carrierChannelFilterApplicationSel, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
        {
            ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
            return recoveryAction;
        }
    }
    else
    {
        recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
        ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, rxFlag, "Invalid rxFlag");
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;    
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);

    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 272U;
            *assymetricFilterTaps = 0;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 70000U:
            *numberOfFilterTaps = 244U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_70000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_70000) / sizeof(int16_t);
            break;

        case 80000U:
            *numberOfFilterTaps = 254U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_80000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_80000) / sizeof(int16_t);
            break;

        case 90000U:
            *numberOfFilterTaps = 258U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_90000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_90000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 267U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_15360_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);

    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 184U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 77U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_245760_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 200000U:
            *numberOfFilterTaps = 186U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_245760_ibw_200000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_245760_ibw_200000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }
    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_30720_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 25000U:
            *numberOfFilterTaps = 89U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_25000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_25000) / sizeof(int16_t);
            break;

        case 5000U:
            *numberOfFilterTaps = 370U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 278U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 136U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 124U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_491520_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 400000U:
            *numberOfFilterTaps = 186U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_491520_ibw_400000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_491520_ibw_400000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_61440_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 30000U:
            *numberOfFilterTaps = 164U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_61440_ibw_30000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_61440_ibw_30000) / sizeof(int16_t);
            break;

        case 40000U:
            *numberOfFilterTaps = 172U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_61440_ibw_40000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_61440_ibw_40000) / sizeof(int16_t);
            break;

        case 50000U:
            *numberOfFilterTaps = 151U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_61440_ibw_50000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_61440_ibw_50000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_fs_7680_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 46U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_5g_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_5g_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cddc_assign_app_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 15360U:
            recoveryAction = cddc_assign_app_5g_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 245760U:
            recoveryAction = cddc_assign_app_5g_fs_245760_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cddc_assign_app_5g_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 491520U:
            recoveryAction = cddc_assign_app_5g_fs_491520_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 61440U:
            recoveryAction = cddc_assign_app_5g_fs_61440_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cddc_assign_app_5g_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_high_bw_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                            const int16_t** const                   coeffTable,
                                                                            int16_t* const                          coeffTableSize,
                                                                            uint32_t* const                         numberOfFilterTaps,
                                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 249U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 255U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_high_bw_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_high_bw_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cddc_assign_app_high_bw_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 215;
            *assymetricFilterTaps = 0;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 71;
            *assymetricFilterTaps = 0;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 490U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 210U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 108U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 85U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_fs_7680_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 53U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_coefs(  adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cddc_assign_app_lte_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cddc_assign_app_lte_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cddc_assign_app_lte_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_iot_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 10000U:
            *numberOfFilterTaps = 139U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_iot_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_iot_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_iot_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 20000U:
            *numberOfFilterTaps = 125U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cddc_coefs_lte_iot_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cddc_coefs_lte_iot_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_app_lte_iot_coefs(  adi_adrv904x_Device_t* const            device,
                                                                const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                const int16_t** const                   coeffTable,
                                                                int16_t* const                          coeffTableSize,
                                                                uint32_t* const                         numberOfFilterTaps,
                                                                uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cddc_assign_app_lte_iot_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cddc_assign_app_lte_iot_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 279U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 70000U:
            *numberOfFilterTaps = 240U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_70000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_70000) / sizeof(int16_t);
            break;

        case 80000U:
            *numberOfFilterTaps = 252U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_80000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_80000) / sizeof(int16_t);
            break;

        case 90000U:
            *numberOfFilterTaps = 262U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_90000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_90000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 277U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_15360_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 138U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 92U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_245760_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 200000U:
            *numberOfFilterTaps = 182U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_245760_ibw_200000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_245760_ibw_200000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_30720_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 25000U:
            *numberOfFilterTaps = 113U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_25000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_25000) / sizeof(int16_t);
            break;

        case 5000U:
            *numberOfFilterTaps = 276U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 208U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 150U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 129U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_491520_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 400000U:
            *numberOfFilterTaps = 182U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_491520_ibw_400000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_491520_ibw_400000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_61440_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 30000U:
            *numberOfFilterTaps = 195U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_61440_ibw_30000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_61440_ibw_30000) / sizeof(int16_t);
            break;

        case 40000U:
            *numberOfFilterTaps = 211U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_61440_ibw_40000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_61440_ibw_40000) / sizeof(int16_t);
            break;

        case 50000U:
            *numberOfFilterTaps = 170U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_61440_ibw_50000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_61440_ibw_50000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_fs_7680_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 62U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_5g_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_5g_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cduc_assign_app_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 15360U:
            recoveryAction = cduc_assign_app_5g_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 245760U:
            recoveryAction = cduc_assign_app_5g_fs_245760_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cduc_assign_app_5g_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 491520U:
            recoveryAction = cduc_assign_app_5g_fs_491520_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 61440U:
            recoveryAction = cduc_assign_app_5g_fs_61440_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cduc_assign_app_5g_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_high_bw_5g_fs_122880_coefs( adi_adrv904x_Device_t* const            device,
                                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                            const int16_t** const                   coeffTable,
                                                                            int16_t* const                          coeffTableSize,
                                                                            uint32_t* const                         numberOfFilterTaps,
                                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 60000U:
            *numberOfFilterTaps = 253U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_60000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_60000) / sizeof(int16_t);
            break;

        case 100000U:
            *numberOfFilterTaps = 256U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_100000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_high_bw_5g_fs_122880_ibw_100000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_high_bw_5g_coefs(   adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 122880U:
            recoveryAction = cduc_assign_app_high_bw_5g_fs_122880_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 171U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_15360_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_15360_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 66U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 344U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_5000) / sizeof(int16_t);
            break;

        case 10000U:
            *numberOfFilterTaps = 170U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_10000) / sizeof(int16_t);
            break;

        case 15000U:
            *numberOfFilterTaps = 88U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_15000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_15000) / sizeof(int16_t);
            break;

        case 20000U:
            *numberOfFilterTaps = 66U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_fs_7680_coefs(  adi_adrv904x_Device_t* const            device,
                                                                    const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                    const int16_t** const                   coeffTable,
                                                                    int16_t* const                          coeffTableSize,
                                                                    uint32_t* const                         numberOfFilterTaps,
                                                                    uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 5000U:
            *numberOfFilterTaps = 66U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_fs_7680_ibw_5000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_fs_7680_ibw_5000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_coefs(  adi_adrv904x_Device_t* const            device,
                                                            const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                            const int16_t** const                   coeffTable,
                                                            int16_t* const                          coeffTableSize,
                                                            uint32_t* const                         numberOfFilterTaps,
                                                            uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cduc_assign_app_lte_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cduc_assign_app_lte_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 7680U:
            recoveryAction = cduc_assign_app_lte_fs_7680_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_iot_fs_15360_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 10000U:
            *numberOfFilterTaps = 241U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_iot_fs_15360_ibw_10000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_iot_fs_15360_ibw_10000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_iot_fs_30720_coefs( adi_adrv904x_Device_t* const            device,
                                                                        const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                        const int16_t** const                   coeffTable,
                                                                        int16_t* const                          coeffTableSize,
                                                                        uint32_t* const                         numberOfFilterTaps,
                                                                        uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_NONE;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->ibw_kHz)
    {
        case 20000U:
            *numberOfFilterTaps = 158U;
            *assymetricFilterTaps = 0U;
            *coeffTable = &adrv904x_cduc_coefs_lte_iot_fs_30720_ibw_20000[0];
            *coeffTableSize = sizeof(adrv904x_cduc_coefs_lte_iot_fs_30720_ibw_20000) / sizeof(int16_t);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->ibw_kHz, "Unsupported IBW Frequency");
            return recoveryAction;
            break;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_app_lte_iot_coefs(  adi_adrv904x_Device_t* const            device,
                                                                const adi_adrv904x_CarrierCfg_t* const  carrierCfg,
                                                                const int16_t** const                   coeffTable,
                                                                int16_t* const                          coeffTableSize,
                                                                uint32_t* const                         numberOfFilterTaps,
                                                                uint8_t* const                          assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierCfg->sampleRate_kHz)
    {
        case 15360U:
            recoveryAction = cduc_assign_app_lte_iot_fs_15360_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case 30720U:
            recoveryAction = cduc_assign_app_lte_iot_fs_30720_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierCfg->sampleRate_kHz, "Unsupported Sample Rate");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cddc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierChannelFilterApplicationSel)
    {
        case ADI_ADRV904X_CARRIER_FILTER_5G:
            recoveryAction = cddc_assign_app_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_HIGH_BW_5G:
            recoveryAction = cddc_assign_app_high_bw_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE:
            recoveryAction = cddc_assign_app_lte_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE_IOT:
            recoveryAction = cddc_assign_app_lte_iot_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierChannelFilterApplicationSel, "Unsupported Carrier Channel Filter Application Select");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }

    return recoveryAction;
}

static adi_adrv904x_ErrAction_e cduc_assign_coefs(  adi_adrv904x_Device_t* const                        device,
                                                    const adi_adrv904x_CarrierFilterApplicationType_e   carrierChannelFilterApplicationSel,
                                                    const adi_adrv904x_CarrierCfg_t* const              carrierCfg,
                                                    const int16_t** const                               coeffTable,
                                                    int16_t* const                                      coeffTableSize,
                                                    uint32_t* const                                     numberOfFilterTaps,
                                                    uint8_t* const                                      assymetricFilterTaps)
{
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;

    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierCfg);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTable);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, coeffTableSize);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, numberOfFilterTaps);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, assymetricFilterTaps);
    
    switch (carrierChannelFilterApplicationSel)
    {
        case ADI_ADRV904X_CARRIER_FILTER_5G:
            recoveryAction = cduc_assign_app_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_HIGH_BW_5G:
            recoveryAction = cduc_assign_app_high_bw_5g_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE:
            recoveryAction = cduc_assign_app_lte_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        case ADI_ADRV904X_CARRIER_FILTER_LTE_IOT:
            recoveryAction = cduc_assign_app_lte_iot_coefs(device, carrierCfg, coeffTable, coeffTableSize, numberOfFilterTaps, assymetricFilterTaps);
            break;

        default:
            recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
            ADI_PARAM_ERROR_REPORT(&device->common, recoveryAction, carrierChannelFilterApplicationSel, "Unsupported Carrier Channel Filter Application Select");
            return recoveryAction;
            break;
    }

    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
    {
        ADI_API_ERROR_REPORT(&device->common, recoveryAction, ADI_NO_ERROR_MESSAGE);
        return recoveryAction;
    }
    return recoveryAction;
}

ADI_API adi_adrv904x_ErrAction_e adrv904x_CarrierDelaySlotShuffleSet(   adi_adrv904x_Device_t* const                            device,
                                                                        const adi_adrv904x_CarrierRadioCfg_t* const             carrierConfigs,
                                                                        const adi_adrv904x_ChannelFilterOutputCfg_t* const      carrierChannelFilter,
                                                                        adi_adrv904x_CarrierReconfigProfileCfgOut_t* const      carrierConfigsOut,
                                                                        const uint8_t                                           rxFlag)
{
    
    adi_adrv904x_ErrAction_e recoveryAction = ADI_ADRV904X_ERR_ACT_CHECK_PARAM;
    int ziter = 0;
    int miter = 0;
    int citer = 0;
    int move_iter = 0;
    int i = 0;
    uint8_t bStopSearchOnConvergence = 1u;
    
    adi_adrv904x_CarrierReconfigProfileCfgOut_t cducStateMinDelay;
    adrv904x_CarrierJesdParameters_t default_jesd_prm;
    adrv904x_CarrierJesdParameters_t jesd_prm;
    adrv904x_SlotTableShuffleParams_t slot_prm;
    adrv904x_SlotTableShuffleParams_t slot_prm_copy;
    adrv904x_ShuffleDiag_t diag;
    
    ADI_ADRV904X_NULL_DEVICE_PTR_RETURN(device);
    ADI_FUNCTION_ENTRY_LOG(&device->common, ADI_HAL_LOG_API_PRIV);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigs);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierChannelFilter);
    ADI_ADRV904X_NULL_PTR_REPORT_RETURN(&device->common, carrierConfigsOut);
    
    /* Ignore rxFlag for now. Only Tx is going to be shuffled */
    (void)rxFlag;
        
    /* Initialize cducStateMinDelay solution with MAXIMUM delay value */
    ADI_LIBRARY_MEMSET(&cducStateMinDelay, 0, sizeof(adi_adrv904x_CarrierReconfigProfileCfgOut_t));
    cducStateMinDelay.delayCfg.delayMismatch_cc = __INT16_MAX__;
    
    ADI_LIBRARY_MEMSET(&default_jesd_prm, 0, sizeof(adrv904x_CarrierJesdParameters_t));
    ADI_LIBRARY_MEMSET(&jesd_prm, 0, sizeof(adrv904x_CarrierJesdParameters_t));
    ADI_LIBRARY_MEMSET(&slot_prm, 0, sizeof(adrv904x_SlotTableShuffleParams_t));
    ADI_LIBRARY_MEMSET(&slot_prm_copy, 0, sizeof(adrv904x_SlotTableShuffleParams_t));
    ADI_LIBRARY_MEMSET(&diag, 0, sizeof(adrv904x_ShuffleDiag_t));
    
    default_jesd_prm.frequency_kHz = carrierConfigsOut->internalJesdCfg.frequencyKhz;
    default_jesd_prm.divide = carrierConfigsOut->internalJesdCfg.divide;
    default_jesd_prm.numSlots = carrierConfigsOut->internalJesdCfg.numSlots;
    default_jesd_prm.maxSlot = carrierConfigsOut->internalJesdCfg.maxSlot;
    default_jesd_prm.ifaceMaxSlot = carrierConfigsOut->internalJesdCfg.ifaceMaxSlot;
    default_jesd_prm.initSlot = carrierConfigsOut->internalJesdCfg.initSlot;
    default_jesd_prm.slotValid = carrierConfigsOut->internalJesdCfg.slotValid;
    for (i = 0; i < (int)ADI_ADRV904X_NO_OF_JESD_CARRIER_SLOTS; i++)
    {
        default_jesd_prm.slotTable[i] = carrierConfigsOut->internalJesdCfg.slotTable[i];
    }
    for (i = 0; i < (int)ADI_ADRV904X_MAX_NO_OF_JESD_IFACE_SLOTS; i++)
    {
        default_jesd_prm.ifaceSlotTable[i] = carrierConfigsOut->internalJesdCfg.ifaceSlotTable[i];
    }
    
    /* Start Timer for Shuffling Here: */
    uint32_t start = 0U;
    uint32_t end = 0U;
    start = (uint32_t)ADI_LIBRARY_CLOCK();
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Diagnositic timer start = %d clocks", start);
#endif
    /* Mark shuffling as enabled but not yet converged */
    diag.enabled = 1u;
    diag.converged = 0u;
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    int default_iface_table_size = (int)carrierConfigsOut->internalJesdCfg.ifaceMaxSlot;
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Default iface slot table size = %d", default_iface_table_size);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Default carrier slot table size = %d", carrierConfigsOut->internalJesdCfg.numSlots);
#endif
    /* Seed internal implementation of prbs with a known starting value */
    adiLfsrSeedSet(device, ADI_LFSR_START_SEED); 
    
    /* ziter: Brute force randomized (or psuedo-random) starting slot table
     *  - 0:    Default jesd_prm table
     *  - else: Randomly generated jesd_prm table
     */
    for (ziter = 0; ziter < (int)ADI_SLOT_SHUFFLE_RAND_ITERATIONS; ziter++)
    {
        if ((bStopSearchOnConvergence == 1u) && (diag.converged == 1u))
        {
            break;
        }
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Start ziter = %d", ziter);
#endif
        /* Always start new table gen with fresh copy of default_jesd_prm --> jesd_prm */
        ADI_LIBRARY_MEMCPY(&jesd_prm, &default_jesd_prm, sizeof(jesd_prm));

        if ((ziter > 0) || (ADI_SLOT_SHUFFLE_USE_ONLY_RAND == 1))
        {
            /* Generate a random table */
            recoveryAction = randomTableGenWrapper(device, carrierConfigs, &jesd_prm);
            if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE)
            {
                return recoveryAction;
            }
        }

        /* miter:
         *  legacy:
         *      - 0: Default number of JESD IFACE slots needed. min_num_slots = 8 
         *      - 1: Attempt to increase number of JESD IFACE slots used. min_num_slots = 16
         *  current:
         *      - There is no ability to change iface slot table size at runtime. Must use initial slot table size
         */
        for (miter = 0; miter < 1; miter++)
        {
            if (bStopSearchOnConvergence && (diag.converged == 1u))
            {
                break;
            }
            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Start miter = %d", miter);
        
            for (citer = 0; citer < 3; citer++)
            {
                if (bStopSearchOnConvergence && (diag.converged == 1u))
                {
                    break;
                }
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Start citer = %d", citer);
#endif
                /* Revert CDUC struct with fresh transfer of jesd_prm --> cduc */
                /* transfer jesd configuration to CDUC output data struct */
                transferJesdConfigToOutputCfg(device, carrierConfigsOut, &jesd_prm);

                switch (citer)
                {
                    /* Start with original/basic slot tables first */
                    case (0):
                        /* Do Nothing */
                        break;

                    /* Try Swap carriers */
                    case (1):
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Swapping carriers:", 0);
#endif
                        /* Copy data from CDUC --> Shuffle prms */
                        recoveryAction = removeDummyCarriers(device, carrierConfigsOut);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                        recoveryAction = transferSlotTableConfig(device, carrierConfigsOut, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                        recoveryAction = transferDelayMismatch(device, carrierConfigsOut, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                        /* Swap in Shuffle prms */
                        recoveryAction = swapSimilarCarriers(device, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                        /* Copy data from Shuffle prms --> CDUC */
                        recoveryAction = transferJesdConfigShuffleToJesd(device, carrierConfigsOut, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                        recoveryAction = reinsertDummyCarriers(device, carrierConfigsOut);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                        break;
                
                    /* Try reordered/flipped slot tables */
                    case (2):
                    default:
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Reordering/Flipping carriers:", 0);
#endif
                    /* Copy data from CDUC --> Shuffle prms */
                    recoveryAction = removeDummyCarriers(device, carrierConfigsOut);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                    recoveryAction = transferSlotTableConfig(device, carrierConfigsOut, &slot_prm);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                    recoveryAction = transferDelayMismatch(device, carrierConfigsOut, &slot_prm);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                    /* Reorder table in shuffle parameters */
                    recoveryAction = reorderSlotTable(device, &slot_prm);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                    /* Copy data from Shuffle prms --> CDUC */
                    recoveryAction = transferJesdConfigShuffleToJesd(device, carrierConfigsOut, &slot_prm);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                    recoveryAction = reinsertDummyCarriers(device, carrierConfigsOut);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                    break;
                }

                /* Try 20 carrier "moves" per {miter, citer} permutation */
                for (move_iter = 0; move_iter < 20; move_iter++)
                {
                    /* Update shuffle diagnostic values */
                    diag.ziter = ziter;
                    diag.miter = miter;
                    diag.citer = citer;
                    diag.move_iter = move_iter;

                    /* Recalc delay and update min state */
                    recoveryAction = adrv904x_CducDelayConfigurationCalculate(device, carrierConfigs, carrierChannelFilter, carrierConfigsOut);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    
                    recoveryAction = updateMinDelayCducSolution(device, carrierConfigsOut, &cducStateMinDelay);
                    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                    /* Debug print cduc state info */
                    ADI_VARIABLE_LOG(&device->common,
                        ADI_HAL_LOG_MSG,
                        "Shuffle #{z, m, c, move} = {%d, %d, %d, %d}: ", 
                        ziter, 
                        miter, 
                        citer, 
                        move_iter);
                    printfCducState(device, carrierConfigsOut);
                    printfCmodelStats(device, carrierConfigsOut, carrierChannelFilter);
#endif

                    if (carrierConfigsOut->delayCfg.delayMismatch_cc > ADRV904X_HALF_MAX_DELAY_CC * 2)
                    {
                        /* Copy data from CDUC --> Shuffle prms */
                        recoveryAction = removeDummyCarriers(device, carrierConfigsOut);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                        
                        recoveryAction = transferSlotTableConfig(device, carrierConfigsOut, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                        
                        recoveryAction = transferDelayMismatch(device, carrierConfigsOut, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                        /* Move carrier position in shuffle prms */
                        ADI_LIBRARY_MEMCPY(&slot_prm_copy, &slot_prm, sizeof(slot_prm_copy));
                        recoveryAction = moveCarrierPositions(device, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

                        /* Check that a carrier moved. If not --> break out of move_carrier loop */
                        int bMoveDeadEnd = !ADI_LIBRARY_MEMCMP(&slot_prm_copy, &slot_prm, sizeof(slot_prm_copy));
                        if (bMoveDeadEnd)
                        {
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                            ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "DEADEND: moveCarrierPositions() sequence hit a dead end.", 0);
#endif
                            break;
                        }

                        /* Copy data from Shuffle prms --> CDUC */
                        recoveryAction = transferJesdConfigShuffleToJesd(device, carrierConfigsOut, &slot_prm);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                        recoveryAction = reinsertDummyCarriers(device, carrierConfigsOut);
                        if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }
                    }
                    else
                    {
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
                        ADI_VARIABLE_LOG(&device->common,
                            ADI_HAL_LOG_MSG,
                            "Delay minimized to mismatch = %dns; ziter = %d, miter = %d, citer = %d, Move Iteration = %d",
                            carrierConfigsOut->delayCfg.delayMismatch_cc,
                            ziter,
                            miter, 
                            citer, 
                            move_iter);
#endif
                        diag.converged = 1u;
                        break;

                    }
                } /* end: iter loop around moveCarrierPositions */
            
            } /* end: citer loop */

        } /* end: miter forloop */

    } /* end: ziter forloop */

#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    printfCmodelStats(device, carrierConfigsOut, carrierChannelFilter);
#endif
    
    /* Update final cduc structure to use cduc state of Min Delay Solution */
    ADI_LIBRARY_MEMCPY(carrierConfigsOut, &cducStateMinDelay, sizeof(adi_adrv904x_CarrierReconfigProfileCfgOut_t));

#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    /* Debug Final print cduc state info */
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Final Slot Table Result:", 0);
    printfCducState(device, carrierConfigsOut);
    printfCmodelStats(device, carrierConfigsOut, carrierChannelFilter);

    /* One last calculation of delay for debug */
    recoveryAction = adrv904x_CducDelayConfigurationCalculate(device, carrierConfigs, carrierChannelFilter, carrierConfigsOut);
    if (recoveryAction != ADI_ADRV904X_ERR_ACT_NONE) { return recoveryAction; }

#endif
    
    /* Stop Timer for Shuffling Here: */
    end = ADI_LIBRARY_CLOCK();
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Diagnositic timer end = %d clocks", end);
#endif 
    /* Convert timer to us and store */
    diag.procTime_us = (uint32_t)((end - start) * 1e6 / ADI_LIBRARY_CLOCKS_PER_SEC);
#if (ADI_ENABLE_DELAY_MATCHING_LOG_PRINTS == 1)
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "---------------------------------------------------------------", 0);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Delay Matching Done:", 0);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "    Slot Shuffle Algorithm delayMismatch_cc = %d cc", carrierConfigsOut->delayCfg.delayMismatch_cc);

    if (diag.converged == 1u)
    {
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "    CONVERGED", 0);
    }
    else
    {
        ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "    DIVERGED", 0);
    }
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "Shuffling Elapsed time = %d us", diag.procTime_us);
    ADI_VARIABLE_LOG(&device->common, ADI_HAL_LOG_MSG, "---------------------------------------------------------------", 0);
#endif
    return recoveryAction;
}    

