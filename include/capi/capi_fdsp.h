/*
 * Copyright (c) 2024-2025 Analog Devices, Inc.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/**
 * @file
 * @brief FastDSP Common API
 *
 * The FastDSP is a digital signal processing core designed to efficiently run
 * biquad filter chains, dynamic range control, mixing, and other functions for
 * low-latency signal paths.
 *
 * This driver aids in the runtime operation of the FastDSP by offering:
 * - Initial loading of program and parameters
 * - Start, stop, pause, and resume state control
 * - Parameter bank switching
 * - Envelope, conditional execution, and safe loading control
 *
 * Refer to the FastDSP architecture documentation for details on the instruction
 * set, parameter formats, and input and output mappings.
 */

#ifndef CAPI_FDSP_H
#define CAPI_FDSP_H

#include <stdint.h>
#include <stdbool.h>

#if defined(__cplusplus)
extern "C" {
#endif /* _cplusplus */

/**
 * @brief FastDSP operation types
 */
enum capi_fdsp_operation {
	CAPI_FDSP_OPERATION_LIMIT,  /**< FastDSP limiter operation */
	CAPI_FDSP_OPERATION_EXPAND, /**< FastDSP expander operation */
};

/**
 * @brief Bank select
 */
enum capi_fdsp_bank_sel {
	CAPI_FDSP_BANK_SEL_A,  /**< Select Parameter Bank A */
	CAPI_FDSP_BANK_SEL_B,  /**< Select Parameter Bank B */
	CAPI_FDSP_BANK_SEL_C,  /**< Select Parameter Bank C */
	CAPI_FDSP_BANK_SEL_MAX /**< Parameter Bank selection invalid */
};

/**
 * @brief Bank switch ramp rate
 */
enum capi_fdsp_ramp_rate {
	CAPI_FDSP_RAMP_RATE_20MS,   /**< 0.02 second ramp */
	CAPI_FDSP_RAMP_RATE_40MS,   /**< 0.04 second ramp */
	CAPI_FDSP_RAMP_RATE_60MS,   /**< 0.06 second ramp */
	CAPI_FDSP_RAMP_RATE_80MS,   /**< 0.08 second ramp */
	CAPI_FDSP_RAMP_RATE_100MS,  /**< 0.10 second ramp */
	CAPI_FDSP_RAMP_RATE_150MS,  /**< 0.15 second ramp */
	CAPI_FDSP_RAMP_RATE_200MS,  /**< 0.20 second ramp */
	CAPI_FDSP_RAMP_RATE_250MS,  /**< 0.25 second ramp */
	CAPI_FDSP_RAMP_RATE_300MS,  /**< 0.30 second ramp */
	CAPI_FDSP_RAMP_RATE_500MS,  /**< 0.50 second ramp */
	CAPI_FDSP_RAMP_RATE_750MS,  /**< 0.75 second ramp */
	CAPI_FDSP_RAMP_RATE_1000MS, /**< 1.00 second ramp */
	CAPI_FDSP_RAMP_RATE_1250MS, /**< 1.25 second ramp */
	CAPI_FDSP_RAMP_RATE_1500MS, /**< 1.50 second ramp */
	CAPI_FDSP_RAMP_RATE_1750MS, /**< 1.75 second ramp */
	CAPI_FDSP_RAMP_RATE_2000MS, /**< 2.00 second ramp */
	CAPI_FDSP_RAMP_RATE_MAX     /**< Max Ramp rate*/
};

/**
 * @brief Conditional execution
 */
enum capi_fdsp_conditional_execution {
	CAPI_FDSP_CONDITIONAL_EXECUTION0,   /**< Conditional instruction execution register 0 */
	CAPI_FDSP_CONDITIONAL_EXECUTION1,   /**< Conditional instruction execution register 1 */
	CAPI_FDSP_CONDITIONAL_EXECUTION2,   /**< Conditional instruction execution register 2 */
	CAPI_FDSP_CONDITIONAL_EXECUTION3,   /**< Conditional instruction execution register 3 */
	CAPI_FDSP_CONDITIONAL_EXECUTION4,   /**< Conditional instruction execution register 4 */
	CAPI_FDSP_CONDITIONAL_EXECUTION5,   /**< Conditional instruction execution register 5 */
	CAPI_FDSP_CONDITIONAL_EXECUTION6,   /**< Conditional instruction execution register 6 */
	CAPI_FDSP_CONDITIONAL_EXECUTION7,   /**< Conditional instruction execution register 7 */
	CAPI_FDSP_CONDITIONAL_EXECUTION_MAX /**< Conditional instruction execution register invalid
					     */
};

/**
 * @brief FastDSP configuration
 */
struct capi_fdsp_config {
	/** Base address */
	uint64_t identifier;
	/** Clock signal source */
	uint32_t rate_source;
	/** Clock signal division factor */
	uint16_t rate_division;
	/** The number of instructions run per sample based on the configured clock */
	uint16_t instruction_length;
	/** Pointer to the FastDSP program data generated by the assembler */
	int *program;
	/** Pointer to the FastDSP parameter data generated by the assembler */
	int *parameters;
	/** Pointer to the FastDSP state data generated by the assembler */
	int *state;
	/** Platform specific FastDSP platform ops structure */
	const struct capi_fdsp_ops *ops;
	/** This is intended to store FastDSP specific configurations */
	void *extra;
};

/**
 * @brief FastDSP handle
 *
 * Drivers may need own handle type to handle internals.
 * Driver developer shall declare this as the first field of private handle structure.
 */
struct capi_fdsp_handle {
	/** FastDSP ID */
	uint32_t fdsp_id;
	/** The number of instructions run per sample based on the configured clock */
	uint16_t instruction_length;
	/** Base address of the FastDSP parameter, state, and program memories */
	uint32_t mem_addr;
	/** If true, the driver is owner of handle memory */
	bool init_allocated;
	/** set and used by capi thin layer */
	const struct capi_fdsp_ops *ops;
	/** set and used by capi thin layer if locking is available */
	void *lock;
	/** set and used by user optionally */
	void *priv;
};

/**
 * @brief FastDSP parameter structure.
 */
struct capi_fdsp_params {
	/** Parameter 0 */
	uint32_t p0;
	/** Parameter 1 */
	uint32_t p1;
	/** Parameter 2 */
	uint32_t p2;
	/** Parameter 3 */
	uint32_t p3;
	/** Parameter 4 */
	uint32_t p4;
};

/**
 * @brief Initialize the FastDSP Instance.
 *
 * Perform the initial configuration of the FastDSP, and the FastDSP handler.
 * This copies the program, parameters, and initial state into the memory
 * space of the FastDSP. It also configures the clock speed, rate source,
 * and rate division. The FastDSP must be stopped before initialization; it
 * remains stopped after initialization
 *
 * The program, parameters, and initial state must be generated from the FastDSP
 * assembler before compile time
 *
 * @param[in] handle Pointer to FastDSP controller handler pointer
 * @param[in] config Pointer to FastDSP configuration structure
 *
 * @return int 0 for success or error code
 */
int capi_fdsp_init(struct capi_fdsp_handle **handle, const struct capi_fdsp_config *config);

/**
 * @brief Deinitialize the FastDSP Instance
 *
 * Reset the FastDSP configuration to its initial state and power it down.
 * The FastDSP must be stopped first before calling this function. Program,
 * parameter, and state memories are wiped after calling this function
 *
 * @param[in] handle Pointer to FastDSP controller handler
 *
 * @retval 0 Deinitialization completed successfully
 * @retval EINVAL when the handler is NULL, or the FastDSP is currently running
 */
int capi_fdsp_deinit(const struct capi_fdsp_handle *handle);

/**
 * @brief Start the FastDSP.
 *
 * Release the FastDSP from reset and begin program execution as samples
 * are received.
 *
 * @param[in] handle Pointer to the FastDSP controller handler
 * @param[out] exec_state Pointer to the FastDSP execution state
 *             true: execution started successfully false : already running
 *
 * @return int 0 for success or error code
 */
int capi_fdsp_start(const struct capi_fdsp_handle *handle, bool *exec_state);

/**
 * @brief Stop the FastDSP.
 *
 * Stop FastDSP program execution.
 *
 * @param[in] handle Pointer to the FastDSP controller handler
 * @param[out] exec_state Pointer to the FastDSP execution state
 *             true: execution stopped successfully false : already stopped
 *
 * @return int 0 for success or error code
 */
int capi_fdsp_stop(const struct capi_fdsp_handle *handle, bool *exec_state);

/**
 * @brief Resume FastDSP program execution.
 *
 * Resume FastDSP program execution after a pause instruction has been issued
 *
 * Refer to the FastDSP instruction documentation for details of the pause
 * instruction.
 *
 * @param[in] handle Pointer to the FastDSP controller handler
 * @param[out] exec_state Pointer to the FastDSP execution state
 *             true: execution resumed successfully false : already running
 *
 * @return int 0 for success or error code
 */
int capi_fdsp_resume(const struct capi_fdsp_handle *handle, bool *exec_state);

/**
 * @brief Configure the FastDSP memory parity checking.
 *
 * The FastDSP is capable of performing a parity check on the program,
 * parameter, and state memories. This may be used to enable or disable the
 * check.
 *
 * If a parity error is detected, the FastDSP will halt. Refer to the FastDSP
 * hardware documentation for further details on the parity check, and the
 * behavior of the FastDSP when an error is detected.
 *
 * @param[in] handle Pointer to the FastDSP controller handler
 * @param[in] check True to enable, false to disable parity checking
 *
 * @retval 0 parity check successfully configured
 * @retval EINVAL parity check could not be configured
 */
int capi_fdsp_set_parity_check(const struct capi_fdsp_handle *handle, bool check);

/**
 * @brief Switch the active parameter bank immediately.
 *
 * Switch the active parameter bank without ramping between the old
 * bank and the new bank.
 *
 * Zeroing the state of the FastDSP during switching can be controlled
 * with the zero parameter. When switching active parameter banks between
 * two settings, zeroing the state of the bank prevents the new filter
 * settings from being active on old data that is recirculating in filters.
 * Zeroing the state may prevent filter instability or unwanted noises
 * upon bank switching.
 *
 * The FastDSP must be in the active running state to perform the
 * bank switch.
 *
 * @param[in] handle Pointer to the FastDSP controller handler
 * @param[in] bank The new bank to switch to
 * @param[in] zero Zero the state of the FastDSP data memory during bank switching
 *
 * @retval 0 bank switch completed successfully
 * @retval EINVAL when the handler is NULL, or the FastDSP is stopped or paused
 * @retval EALREADY the current bank is the new bank
 */
int capi_fdsp_switch_bank_immediate(const struct capi_fdsp_handle *handle,
				    enum capi_fdsp_bank_sel bank, bool zero);

/**
 * @brief Switch the active parameter bank over a period of time.
 *
 * Switch the active parameter bank by linearly interpolating parameters
 * from the old bank to the new bank over a period of time. The rate of
 * the ramp can be controlled with the rate parameter.
 *
 * The interpolation between the banks can be stopped prematurely by specifying
 * a value between 0.0 and 1.0 with the stop parameter. This value is quantized
 * to the nearest 1/64th. A value of 1.0 will fully switch from the old bank to
 * the new bank.
 *
 * Zeroing the state of the FastDSP during switching can be controlled
 * with the zero parameter. When switching active parameter banks between
 * two settings, zeroing the state of the bank prevents the new filter
 * settings from being active on old data that is recirculating in filters.
 * Zeroing the state may prevent filter instability or unwanted noises
 * upon bank switching.
 *
 * The FastDSP must be in the active running state to perform the
 * bank switch.
 *
 * @param[in] handle Pointer to the FastDSP controller handler
 * @param[in] bank The new bank to switch to
 * @param[in] zero Zero the state of the FastDSP data memory during bank switching
 * @param[in] stop The point at which to stop the interpolation between banks
 * @param[in] rate The rate at which to ramp from the old bank to the new bank
 *
 * @retval 0 bank switch completed successfully
 * @retval EINVAL when the handler is NULL, or the FastDSP is stopped or paused, or stop is less
 * than 0.0 or greater than 1.0
 * @retval EALREADY the current bank is the new bank
 */
int capi_fdsp_switch_bank_ramp(const struct capi_fdsp_handle *handle, enum capi_fdsp_bank_sel bank,
			       bool zero, float stop, enum capi_fdsp_ramp_rate rate);

/**
 * @brief Copy the contents from one parameter bank to another.
 *
 * Copy the contents from one bank to another. Any unused bank can be copied
 * to any other unused bank. The active bank can be copied to any unused
 * bank. Unused banks cannot be copied to the active bank.
 *
 * The bank copy is performed on the next frame boundary after calling
 * this function.
 *
 * @param [in] handle Pointer to the FastDSP controller handler
 * @param [in] source The source bank
 * @param [in] destination The destination bank
 *
 * @retval 0 Copy from source to destination completed successfully
 * @retval EINVAL when the handler is NULL, the FastDSP is stopped or paused, the source and
 * destination are the same, the destination is the active bank
 * @retval ENOTSUP the source or destination is not supported
 */
int capi_fdsp_copy_bank(const struct capi_fdsp_handle *handle, enum capi_fdsp_bank_sel source,
			enum capi_fdsp_bank_sel destination);

/**
 * @brief Set the attack and decay rates for FastDSP operations.
 *
 * Set the attack and decay rate factors for the limiter and expander operations.
 * Each operation has its own set of envelope parameters. Valid ranges are
 * between 0.0 and 1.0 and are quantized to the nearest 1/32nd.
 *
 * @param [in] handle Pointer to the FastDSP controller handler
 * @param [in] operation Select either the limiter or the expander
 * @param [in] attack Attack rate factor between 0.0 and 1.0, quantized to the nearest 1/32nd
 * @param [in] decay Decay rate factor between 0.0 and 1.0, quantized to the nearest 1/32nd
 *
 * @retval 0 Envelope successfully set for the specified operation
 * @retval EINVAL When the handler is NULL, or the attack or decay are outside the range of 0.0
 * and 1.0
 * @retval ENOTSUP Unsupported operation selected
 */
int capi_fdsp_set_envelope(const struct capi_fdsp_handle *handle,
			   enum capi_fdsp_operation operation, float attack, float decay);

/**
 * @brief Set the modulo N counter for conditional execution.
 *
 * Set the counter to execute instructions with the MODn condition bit set
 * every N frames. Valid ranges are 0 to 63. A value of 0 executes
 * instructions every frame, a value of 63 executes instructions every
 * 64th frame. If instructions do not have the MODn condition bit set,
 * they are executed every frame, regardless of the value of the modulus
 * counter.
 *
 * @param [in] handle Pointer to the FastDSP controller handler
 * @param [in] modulus modulus counter value to execute MODn conditional instructions
 *
 * @retval 0 Modulus counter successfully set
 * @retval EINVAL When the handler is NULL, or the modulus value is outside the range of 0 to 63
 */
int capi_fdsp_set_modulus_condition(const struct capi_fdsp_handle *handle, uint8_t modulus);

/**
 * @brief Set conditional execution.
 *
 * Set the specified conditional execution bit to true. Instructions
 * that have the specified conditional bit set will execute every frame.
 *
 * @param [in] handle Pointer to the FastDSP controller handler
 * @param [in] condition Specific condition to set
 *
 * @retval 0 Condition set successfully
 * @retval EINVAL When the handler is NULL, or the condition does not exist
 */
int capi_fdsp_set_condition(const struct capi_fdsp_handle *handle,
			    enum capi_fdsp_conditional_execution condition);

/**
 * @brief Clear conditional execution.
 *
 * Clear the specified conditional execution bit to false. Instructions
 * that have the specified conditional bit set will not execute.
 *
 * @param [in] handle Pointer to the FastDSP controller handler
 * @param [in] condition Specific condition to clear
 *
 * @retval 0 Condition cleared successfully
 * @retval EINVAL When the handler is NULL, or the condition does not exist
 */
int capi_fdsp_clear_condition(const struct capi_fdsp_handle *handle,
			      enum capi_fdsp_conditional_execution condition);

/**
 * @brief Safe load parameter values.
 *
 * Used to safely update parameter values of a single instruction of the
 * active bank without interrupting the audio processing, or requiring to
 * deactivate the current bank.
 *
 * The format of the data in parameters depends on the type of instruction
 * at the given address. Refer to the FastDSP instruction documentation on
 * parameter formats for each instruction.
 *
 * Parameters are changed on the next frame boundary after calling this
 * function.
 *
 * @param [in] handle Pointer to the FastDSP controller handler
 * @param [in] address Address of the instruction parameters to modify
 * @param [in] parameters Pointer to the new parameters to load
 *
 * @retval 0 Parameters successfully updated
 *
 */
int capi_fdsp_safeload_params(const struct capi_fdsp_handle *handle, uint32_t address,
			      const struct capi_fdsp_params *parameters);

/**
 * @brief Structure holding FastDSP function pointers that point to the platform
 * specific function. See API functions for relevant descriptions.
 */
struct capi_fdsp_ops {
	/** See capi_fdsp_init() */
	int (*init)(struct capi_fdsp_handle **handle, const struct capi_fdsp_config *config);
	/** See capi_fdsp_deinit() */
	int (*deinit)(const struct capi_fdsp_handle *handle);
	/** See capi_fdsp_start() */
	int (*start)(const struct capi_fdsp_handle *handle, bool *exec_state);
	/** See capi_fdsp_stop() */
	int (*stop)(const struct capi_fdsp_handle *handle, bool *exec_state);
	/** See capi_fdsp_resume() */
	int (*resume)(const struct capi_fdsp_handle *handle, bool *exec_state);
	/** See capi_fdsp_set_parity_check() */
	int (*set_parity_check)(const struct capi_fdsp_handle *handle, bool check);
	/** See capi_fdsp_switch_bank_immediate() */
	int (*switch_bank_immediate)(const struct capi_fdsp_handle *handle,
				     enum capi_fdsp_bank_sel bank, bool zero);
	/** See capi_fdsp_switch_bank_ramp() */
	int (*switch_bank_ramp)(const struct capi_fdsp_handle *handle, enum capi_fdsp_bank_sel bank,
				bool zero, float stop, enum capi_fdsp_ramp_rate rate);
	/** See capi_fdsp_copy_bank() */
	int (*copy_bank)(const struct capi_fdsp_handle *handle, enum capi_fdsp_bank_sel source,
			 enum capi_fdsp_bank_sel destination);
	/** See capi_fdsp_set_envelope() */
	int (*set_envelope)(const struct capi_fdsp_handle *handle,
			    enum capi_fdsp_operation operation, float attack, float decay);
	/** See capi_fdsp_set_modulus_condition() */
	int (*set_modulus_condition)(const struct capi_fdsp_handle *handle, uint8_t modulus);

	/** See capi_fdsp_set_condition() */
	int (*set_condition)(const struct capi_fdsp_handle *handle,
			     enum capi_fdsp_conditional_execution condition);
	/** See capi_fdsp_clear_condition() */
	int (*clear_condition)(const struct capi_fdsp_handle *handle,
			       enum capi_fdsp_conditional_execution condition);
	/** See capi_fdsp_safeload_params() */
	int (*safeload_params)(const struct capi_fdsp_handle *handle, uint32_t address,
			       const struct capi_fdsp_params *parameters);
};

#if defined(__cplusplus)
}
#endif

#endif /* CAPI_FDSP_H */
