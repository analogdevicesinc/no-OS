// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2020 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

/* Portions Copyright (c) 2023 Analog Devices, Inc. */

#include "uart.h"
#include "gpio.h"
#include "pic.h"
#include <stdio.h>
#include "i2c_master.h"
#include "spi_master.h"
#include <stdlib.h>
#include "tmc/ic/TMC5130/TMC5130.h"
#include "tmc/ic/TMC4671/TMC4671.h"
#include "hal/Systick.h"

TMC5130TypeDef tmc5130;
ConfigurationTypeDef conf;
ConfigurationTypeDef *config = &conf;

#define TMC5130 tmc5130

#define STOP 0
#define ROTATE_LEFT 1
#define ROTATE_RIGHT 2

#define STOP_STATE_ON (1 << 11)
#define INCREASE_STATE_ON (1 << 12)
#define DECREACE_STATE_ON (1 << 13)

#define STOP_BUTTON (gpio_status & STOP_STATE_ON)
#define INCREASE_BUTTON (gpio_status & INCREASE_STATE_ON)
#define DECREACE_BUTTON (gpio_status & DECREACE_STATE_ON)

struct uart_instance uart_core_uart;
struct gpio_instance gpio0_inst;
struct gpio_instance gpio1_inst;
struct spim_instance spi_inst;
struct i2cm_instance i2c_inst;

static uint8_t reset()
{
	if(!tmc5130_readInt(&TMC5130, TMC5130_VACTUAL))
		tmc5130_reset(&TMC5130);

	return 1;
}

static uint8_t restore()
{
	return tmc5130_restore(&TMC5130);
}

static void configCallback(TMC5130TypeDef *tmc5130, ConfigState completedState)
{
	if(completedState == CONFIG_RESET)
	{
		// Configuration reset completed
		// Change hardware preset registers here
		tmc5130_writeInt(tmc5130, TMC5130_PWMCONF, 0x000500C8);

		// Fill missing shadow registers (hardware preset registers)
		tmc5130_fillShadowRegisters(&TMC5130);
	}
}

void tmc5130_readWriteArray(uint8_t channel, uint8_t *data, size_t length)
{
	spi_master_readwrite(&spi_inst, data, length);
}

uint8_t tmc4671_readwriteByte(uint8_t motor, uint8_t data, uint8_t lastTransfer){
	//Use SPI_EN_ENABLE in spi_master_config when using spi_master_readwrite_byte
	return spi_master_readwrite_byte(&spi_inst, data, lastTransfer);
}

uint8_t tmc6100_readwriteByte(uint8_t motor, uint8_t data, uint8_t lastTransfer){
	//Use SPI_EN_ENABLE in spi_master_config when using spi_master_readwrite_byte
	return spi_master_readwrite_byte(&spi_inst, data, lastTransfer);
}

int main(void) {
	static uint8_t idx = 0;
	static uint32_t pin_state = 0x00FFFFFF;

	//initialize GPIO
	gpio0_inst.instance_name = GPIO0_INST_GPIO_MEM_MAP_NAME;
	gpio_init(&gpio0_inst,
			GPIO0_INST_GPIO_MEM_MAP_BASE_ADDR,
			GPIO0_INST_LINES_NUM,
			GPIO0_INST_GPIO_DIRS);

	gpio1_inst.instance_name = GPIO1_INST_GPIO_MEM_MAP_NAME;
	gpio_init(&gpio1_inst,
			GPIO1_INST_GPIO_MEM_MAP_BASE_ADDR,
			GPIO1_INST_LINES_NUM,
			GPIO1_INST_GPIO_DIRS);

	spi_master_init(&spi_inst,
			SPI0_INST_SPI_MASTER_MEM_MAP_BASE_ADDR,
			SPI0_INST_SLAVE_COUNT,
			SPI0_INST_DATA_WIDTH,
			SPI0_INST_CPOL,
			SPI0_INST_CPHA,
			SPI_IRQ_DISABLE);

	spi_master_config(&spi_inst,
			SPIM_DATA_WIDTH_8BIT,
			SPI0_INST_PRESCALER,
			SPI0_INST_CPOL,
			SPI0_INST_CPHA,
			SPI_SSNP_DISABLE,
			SPI_EN_DISABLE);

	pic_init(CPU0_INST_PICTIMER_START_ADDR);
	systick_init();

#if _UART_ENABLE_INTERRUPTS_
	//setup uart IRQ
	uart_core_uart.intrLevel = UART0_INST_IRQ;
	pic_isr_register(UART0_INST_IRQ, uart_isr, (void *)&uart_core_uart);
#endif

	uart_init(&uart_core_uart,
			UART0_INST_UART_MEM_MAP_BASE_ADDR,
			CPU_FREQUENCY,
			UART0_INST_BAUD_RATE,
			UART0_INST_STOP_BITS,
			UART0_INST_DATA_WIDTH);

	config->reset = reset;
	config->restore = restore;
	config->state = CONFIG_RESET;
	config->configIndex = 0;

	tmc5130_init(&TMC5130, 0/*channel*/, config, &tmc5130_defaultRegisterResetState[0]);
	TMC5130.config->reset();
	tmc5130_setCallback(&TMC5130, configCallback);

#ifdef LSCC_STDIO_UART_APB
	extern struct uart_instance *g_stdio_uart;
	g_stdio_uart = &uart_core_uart;
#endif

	int32_t stop_state = 0;
	int32_t	increase_state = 0;
	int32_t decrease_state = 0;
	int32_t velocity=0;
	unsigned int gpio_status = 0;

	// gpio_output_write(&gpio1_inst,2,0x00);
	gpio_set_direction(&gpio1_inst,11,GPIO_INPUT);
	gpio_set_direction(&gpio1_inst,12,GPIO_INPUT);
	gpio_set_direction(&gpio1_inst,13,GPIO_INPUT);

	printf("Hello RISC-V TRINAMIC!\r\n");

	char str[1];

	while (true) {

//		printf("Hello RISC-V TRINAMIC!\r\n");
//		gpio_output_write(&gpio0_inst, idx, pin_state);
//
//		printf("pin_state: %u\n", pin_state);
//
//		if (++idx == LED_COUNT) {
//			idx = 0;
//			pin_state = ~pin_state;
//		}
//
////		for(int i =0; i<750000; i++);
//		wait(250);
//
//		unsigned int pin = 0;
//
//		gpio_input_get(&gpio1_inst, 0, &pin);
//
//		printf("pins: ");
//		for(int i=0; i<32; i++){
//
//			printf("%u", (pin & (1<<i))? 1: 0);
//
//		}
//		printf("\n");

		gpio_input_get(&gpio1_inst,0,&gpio_status);

		//this calls the configuration procedure if it was not yet called. // writeConfiguration(&TMC5130);
		tmc5130_periodicJob(&tmc5130, systick_getTick());
		//printf("systick %d\n",systick_getTick());

		if(TMC5130.config->state == CONFIG_READY){

			//set acceleration
			tmc5130_writeInt(&tmc5130, TMC5130_AMAX,60000);

			uart_getc(&uart_core_uart, str);

			switch(str[0]){
				case 'w':
					//incrace velocity
					velocity += 8000;
					tmc5130_rotate(&tmc5130,velocity);
					printf("increase velocity\n");
					str[0] = 0;
					break;
				case 's':
					//decrace velocity
					velocity -= 8000;
					tmc5130_rotate(&tmc5130,velocity);
					printf("decrease velocity\n");
					str[0] = 0;
					break;
				case 'a':
					//rotate left
					if(velocity > 0){
						velocity = -velocity;
					}
					tmc5130_rotate(&tmc5130,velocity);
					str[0] = 0;
					printf("rotate left\n");
					break;
				case 'd':
					//rotate right
					if(velocity < 0){
						velocity = -velocity;
					}
					tmc5130_rotate(&tmc5130,velocity);
					str[0] = 0;
					printf("rotate right\n");
					break;
				case 'q':
					//stop
					tmc5130_stop(&tmc5130);
					velocity = 0;
					str[0] = 0;
					printf("stop\n");
					break;
				case 'v':
					//velocity
					printf("velocity %d\n",tmc5130.velocity);
					str[0] = 0;
					break;
			}

			//wait(50);

			if(INCREASE_BUTTON){
				if(!increase_state){
					velocity = velocity + 8000;
					tmc5130_rotate(&tmc5130,velocity);
					printf("increase velocity\n");
				}
			}
			if(DECREACE_BUTTON){
				if(!decrease_state){
					velocity = velocity - 8000;
					tmc5130_rotate(&tmc5130,velocity);
					printf("decreace velocity\n");
				}
			}
//			if(STOP_BUTTON){
//				if(!stop_state){
//					tmc5130_stop(&tmc5130);
//					velocity = 0;
//					printf("stop\n");
//				}
//			}

//			stop_state      = STOP_BUTTON;
			increase_state  = INCREASE_BUTTON;
			decrease_state  = DECREACE_BUTTON;

		}

		//Use SPI_EN_ENABLE in spi_master_config when using spi_master_readwrite_byte
		//uint8_t data = 0;
		//spi_master_readwrite_byte(&spi_inst, 0xff, 0);
		//data = spi_master_readwrite_byte(&spi_inst, 0xff, 1);
		//printf("data: %u\n", data);
		wait(50);

	}

	return 0;
}

